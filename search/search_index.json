{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Projectile motion is governed by Newton\u2019s laws of motion under constant gravitational acceleration. Let\u2019s derive the equations step-by-step. Governing Equations Assume a projectile is launched with initial velocity $ v_0 $ at an angle $ \\theta $ from the horizontal, with no air resistance and constant gravitational acceleration $ g $. The initial conditions are: - Horizontal velocity: $ v_{x0} = v_0 \\cos\\theta $ - Vertical velocity: $ v_{y0} = v_0 \\sin\\theta $ The acceleration is: - $ a_x = 0 $ (no horizontal acceleration) - $ a_y = -g $ (downward gravitational acceleration) The position as a function of time $ t $ is found by integrating the accelerations: - Horizontal: $ x(t) = v_{x0} t = v_0 \\cos\\theta \\, t $ - Vertical: $ y(t) = v_{y0} t - \\frac{1}{2} g t^2 = v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 $ Time of Flight The projectile hits the ground when $ y(t) = 0 $ (assuming launch height is zero): $$ v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 = 0 $$ Factorizing: $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: $t = 0 $ (start) or $ t = \\frac{2 v_0 \\sin\\theta}{g} $ (time of flight). Range The horizontal range $ R $ is the distance traveled when $ t = \\frac{2 v_0 \\sin\\theta}{g} $: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity $ \\sin 2\\theta = 2 \\sin\\theta \\cos\\theta $: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ This is the general form of the range, showing dependence on $ \\theta $, $ v_0 $, and $g $. Family of Solutions The equation $ R = \\frac{v_0^2 \\sin 2\\theta}{g} $ represents a family of solutions parameterized by $ v_0 $ and $ g $. Different initial conditions yield distinct ranges and trajectories. 2. Analysis of the Range The range depends on $ \\sin 2\\theta $, which has a maximum value of 1 when $ 2\\theta = 90^\\circ $, or $ \\theta = 45^\\circ $. Thus, the maximum range is: $$ R_{\\text{max}} = \\frac{v_0^2}{g} \\quad \\text{at} \\quad \\theta = 45^\\circ $$ Initial Velocity ($ v_0 $) : Range scales with $v_0^2 $, so doubling $ v_0 $ quadruples $ R $. Gravitational Acceleration ($ g $) : Range is inversely proportional to $ g \\(. On the Moon (\\) g \\approx 1.62 \\, \\text{m/s}^2 \\(), the range is greater than on Earth (\\) g = 9.81 \\, \\text{m/s}^2 $). Angle ($ \\theta $) : $ R $ is symmetric about $ 45^\\circ $ (e.g., $ \\theta = 30^\\circ $ and $ 60^\\circ $ yield the same range). 3. Practical Applications Sports : A soccer ball\u2019s trajectory depends on kick angle and speed, optimized near $ 45^\\circ $ for distance. Engineering : Artillery and rocket launches adjust $ \\theta $ and $ v_0 $ for target range. Astrophysics : Trajectories on other planets (e.g., Mars, $ g = 3.72 \\, \\text{m/s}^2 $) require adjusted models. Uneven Terrain : Non-zero launch height modifies the time of flight and range (requires quadratic solving). Air Resistance : Introduces damping, reducing range and altering optimal $ \\theta $. 4. Implementation Below is a Python script simulating projectile motion, plotting range vs. angle, and animating a trajectory. Python Code import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants g = 9.81 # m/s^2 (Earth gravity) v0_values = [10, 15, 20] # Initial velocities (m/s) # Range function def range_theta(theta, v0, g): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Trajectory function def trajectory(t, v0, theta, g): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y # Part 1: Range vs Angle Plot theta = np.linspace(0, 90, 91) # Angles from 0 to 90 degrees plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_theta(theta, v0, g) plt.plot(theta, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Part 2: Animation of Trajectory (for v0 = 15 m/s, theta = 45\u00b0) v0_anim = 15 theta_anim = 45 t_flight = 2 * v0_anim * np.sin(np.radians(theta_anim)) / g t = np.linspace(0, t_flight, 100) x, y = trajectory(t, v0_anim, theta_anim, g) fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, max(x) * 1.1) ax.set_ylim(0, max(y) * 1.1) ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Trajectory (v0 = {v0_anim} m/s, \u03b8 = {theta_anim}\u00b0)') ax.grid(True) line, = ax.plot([], [], 'b-', lw=2) point, = ax.plot([], [], 'ro') def init(): line.set_data([], []) point.set_data([], [])RR return line, point def animate(i): line.set_data(x[:i], y[:i]) point.set_data([x[i]], [y[i]]) return line, point anim = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=50, blit=True) plt.close() # Prevents duplicate static plot HTML(anim.to_jshtml()) # Displays animation in Jupyter; save as GIF in VS Code if needed Graphical Outputs Range vs. Angle : The plot shows $ R $vs. \\(\\theta\\) for $ v_0 = 10, 15, 20 \\, \\text{m/s} $, peaking at $ 45^\\circ $. Animation : A trajectory for $ v_0 = 15 \\, \\text{m/s} $ , $ \\theta = 45^\\circ $, showing the parabolic path. Discussion of Limitations Idealized Model : Assumes no air resistance, flat terrain, and constant $ g $. Realistic Factors : Drag : Reduces range; optimal $ \\theta $ shifts below $ 45^\\circ $. Wind : Alters trajectory unpredictably. Height : Non-zero launch height requires solving a quadratic for time of flight. Suggestions : Use numerical methods (e.g., Runge-Kutta) to include drag ($ F_d = -k v^2 $) or wind forces. Conclusion This analysis reveals the elegance of projectile motion\u2019s dependence on $ \\theta $, $ v_0 $, and $ g $, while highlighting its adaptability to real-world scenarios. The computational tools provide visual insights, making it a powerful teaching and engineering tool. Solutions in Colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by Newton\u2019s laws of motion under constant gravitational acceleration. Let\u2019s derive the equations step-by-step.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"Assume a projectile is launched with initial velocity $ v_0 $ at an angle $ \\theta $ from the horizontal, with no air resistance and constant gravitational acceleration $ g $. The initial conditions are: - Horizontal velocity: $ v_{x0} = v_0 \\cos\\theta $ - Vertical velocity: $ v_{y0} = v_0 \\sin\\theta $ The acceleration is: - $ a_x = 0 $ (no horizontal acceleration) - $ a_y = -g $ (downward gravitational acceleration) The position as a function of time $ t $ is found by integrating the accelerations: - Horizontal: $ x(t) = v_{x0} t = v_0 \\cos\\theta \\, t $ - Vertical: $ y(t) = v_{y0} t - \\frac{1}{2} g t^2 = v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 $","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when $ y(t) = 0 $ (assuming launch height is zero): $$ v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 = 0 $$ Factorizing: $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: $t = 0 $ (start) or $ t = \\frac{2 v_0 \\sin\\theta}{g} $ (time of flight).","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"The horizontal range $ R $ is the distance traveled when $ t = \\frac{2 v_0 \\sin\\theta}{g} $: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity $ \\sin 2\\theta = 2 \\sin\\theta \\cos\\theta $: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ This is the general form of the range, showing dependence on $ \\theta $, $ v_0 $, and $g $.","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The equation $ R = \\frac{v_0^2 \\sin 2\\theta}{g} $ represents a family of solutions parameterized by $ v_0 $ and $ g $. Different initial conditions yield distinct ranges and trajectories.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range depends on $ \\sin 2\\theta $, which has a maximum value of 1 when $ 2\\theta = 90^\\circ $, or $ \\theta = 45^\\circ $. Thus, the maximum range is: $$ R_{\\text{max}} = \\frac{v_0^2}{g} \\quad \\text{at} \\quad \\theta = 45^\\circ $$ Initial Velocity ($ v_0 $) : Range scales with $v_0^2 $, so doubling $ v_0 $ quadruples $ R $. Gravitational Acceleration ($ g $) : Range is inversely proportional to $ g \\(. On the Moon (\\) g \\approx 1.62 \\, \\text{m/s}^2 \\(), the range is greater than on Earth (\\) g = 9.81 \\, \\text{m/s}^2 $). Angle ($ \\theta $) : $ R $ is symmetric about $ 45^\\circ $ (e.g., $ \\theta = 30^\\circ $ and $ 60^\\circ $ yield the same range).","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : A soccer ball\u2019s trajectory depends on kick angle and speed, optimized near $ 45^\\circ $ for distance. Engineering : Artillery and rocket launches adjust $ \\theta $ and $ v_0 $ for target range. Astrophysics : Trajectories on other planets (e.g., Mars, $ g = 3.72 \\, \\text{m/s}^2 $) require adjusted models. Uneven Terrain : Non-zero launch height modifies the time of flight and range (requires quadratic solving). Air Resistance : Introduces damping, reducing range and altering optimal $ \\theta $.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script simulating projectile motion, plotting range vs. angle, and animating a trajectory.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants g = 9.81 # m/s^2 (Earth gravity) v0_values = [10, 15, 20] # Initial velocities (m/s) # Range function def range_theta(theta, v0, g): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Trajectory function def trajectory(t, v0, theta, g): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y # Part 1: Range vs Angle Plot theta = np.linspace(0, 90, 91) # Angles from 0 to 90 degrees plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_theta(theta, v0, g) plt.plot(theta, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Part 2: Animation of Trajectory (for v0 = 15 m/s, theta = 45\u00b0) v0_anim = 15 theta_anim = 45 t_flight = 2 * v0_anim * np.sin(np.radians(theta_anim)) / g t = np.linspace(0, t_flight, 100) x, y = trajectory(t, v0_anim, theta_anim, g) fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, max(x) * 1.1) ax.set_ylim(0, max(y) * 1.1) ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Trajectory (v0 = {v0_anim} m/s, \u03b8 = {theta_anim}\u00b0)') ax.grid(True) line, = ax.plot([], [], 'b-', lw=2) point, = ax.plot([], [], 'ro') def init(): line.set_data([], []) point.set_data([], [])RR return line, point def animate(i): line.set_data(x[:i], y[:i]) point.set_data([x[i]], [y[i]]) return line, point anim = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=50, blit=True) plt.close() # Prevents duplicate static plot HTML(anim.to_jshtml()) # Displays animation in Jupyter; save as GIF in VS Code if needed","title":"Python Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-outputs","text":"Range vs. Angle : The plot shows $ R $vs. \\(\\theta\\) for $ v_0 = 10, 15, 20 \\, \\text{m/s} $, peaking at $ 45^\\circ $. Animation : A trajectory for $ v_0 = 15 \\, \\text{m/s} $ , $ \\theta = 45^\\circ $, showing the parabolic path.","title":"Graphical Outputs"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion-of-limitations","text":"Idealized Model : Assumes no air resistance, flat terrain, and constant $ g $. Realistic Factors : Drag : Reduces range; optimal $ \\theta $ shifts below $ 45^\\circ $. Wind : Alters trajectory unpredictably. Height : Non-zero launch height requires solving a quadratic for time of flight. Suggestions : Use numerical methods (e.g., Runge-Kutta) to include drag ($ F_d = -k v^2 $) or wind forces.","title":"Discussion of Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis reveals the elegance of projectile motion\u2019s dependence on $ \\theta $, $ v_0 $, and $ g $, while highlighting its adaptability to real-world scenarios. The computational tools provide visual insights, making it a powerful teaching and engineering tool. Solutions in Colab","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation of motion for a forced damped pendulum is: $ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $ where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external force, - \\( \\omega \\) is the driving frequency. 1.1 Small-Angle Approximation For small angles ($ \\theta \\approx 0 $), we can approximate $ \\sin\\theta \\approx \\theta $, reducing the equation to: $ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) $ which is a driven damped harmonic oscillator , allowing for analytical solutions in simple cases. 1.2 Resonance Condition Resonance occurs when the external forcing frequency \\( \\omega \\) matches the system's natural frequency : $ \\omega_0 = \\sqrt{\\frac{g}{L}} $ At resonance, the pendulum exhibits maximum oscillations, which can lead to instability if damping is low. 2. Analysis of Dynamics 2.1 Effects of Parameters Damping coefficient $ b $ : Higher damping suppresses oscillations, preventing chaotic motion. Driving amplitude $ A $ : Larger values can lead to more complex behavior. Driving frequency $ \\omega $ : Controls resonance effects and synchronization. 2.2 Transition to Chaos At low damping, the system can exhibit period-doubling bifurcations , leading to chaos. Phase portraits and Poincar\u00e9 sections help visualize this transition. 3. Practical Applications Mechanical Systems : Bridges, suspension cables, and earthquake-resistant structures. Electrical Circuits : Analogous to driven RLC circuits . Biomechanics : Human balance and walking dynamics. 4. Implementation: Python Simulation We use Runge-Kutta numerical methods to integrate the equation of motion and plot various behaviors. 4.1 Python Code for Visual Studio Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Pendulum length (m) b = 0.2 # Damping coefficient A = 1.2 # Driving amplitude omega = 2.0 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t_span = (0, 50) # Time range t_eval = np.linspace(*t_span, 1000) # Time points y0 = [0.5, 0] # Initial angle and angular velocity # Solve using Runge-Kutta sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract solutions t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(8, 5)) plt.plot(t, theta, label='Angular Displacement (theta)') plt.xlabel('Time (s)') plt.ylabel('Theta (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid(True) plt.savefig(\"forced_damped_pendulum.png\", dpi=300) plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation of motion for a forced damped pendulum is: $ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) $ where: - \\( \\theta \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external force, - \\( \\omega \\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-small-angle-approximation","text":"For small angles ($ \\theta \\approx 0 $), we can approximate $ \\sin\\theta \\approx \\theta $, reducing the equation to: $ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) $ which is a driven damped harmonic oscillator , allowing for analytical solutions in simple cases.","title":"1.1 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-resonance-condition","text":"Resonance occurs when the external forcing frequency \\( \\omega \\) matches the system's natural frequency : $ \\omega_0 = \\sqrt{\\frac{g}{L}} $ At resonance, the pendulum exhibits maximum oscillations, which can lead to instability if damping is low.","title":"1.2 Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-effects-of-parameters","text":"Damping coefficient $ b $ : Higher damping suppresses oscillations, preventing chaotic motion. Driving amplitude $ A $ : Larger values can lead to more complex behavior. Driving frequency $ \\omega $ : Controls resonance effects and synchronization.","title":"2.1 Effects of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-transition-to-chaos","text":"At low damping, the system can exhibit period-doubling bifurcations , leading to chaos. Phase portraits and Poincar\u00e9 sections help visualize this transition.","title":"2.2 Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Mechanical Systems : Bridges, suspension cables, and earthquake-resistant structures. Electrical Circuits : Analogous to driven RLC circuits . Biomechanics : Human balance and walking dynamics.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"We use Runge-Kutta numerical methods to integrate the equation of motion and plot various behaviors.","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-python-code-for-visual-studio-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Pendulum length (m) b = 0.2 # Damping coefficient A = 1.2 # Driving amplitude omega = 2.0 # Driving frequency # Differential equation def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = - (g / L) * np.sin(theta) - b * omega_t + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions t_span = (0, 50) # Time range t_eval = np.linspace(*t_span, 1000) # Time points y0 = [0.5, 0] # Initial angle and angular velocity # Solve using Runge-Kutta sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract solutions t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(8, 5)) plt.plot(t, theta, label='Angular Displacement (theta)') plt.xlabel('Time (s)') plt.ylabel('Theta (radians)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid(True) plt.savefig(\"forced_damped_pendulum.png\", dpi=300) plt.show()","title":"4.1 Python Code for Visual Studio Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Orbital Radius Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship. Derivation of Kepler's Third Law for Circular Orbits For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) . Implications in Astronomy Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes. Real-World Examples 1. The Moon's Orbit Around Earth Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects). 2. Earth's Orbit Around the Sun Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit. Extension to Elliptical Orbits For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets. Computational Model Python Code for Graphing \\(T^2\\) vs \\(r^3\\) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun). Python Code for Animation of Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab Conclusion Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship.","title":"Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) .","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects).","title":"1. The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-earths-orbit-around-the-sun","text":"Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit.","title":"2. Earth's Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-graphing-t2-vs-r3","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun).","title":"Python Code for Graphing \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-animation-of-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab","title":"Python Code for Animation of Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Definitions First Cosmic Velocity The first cosmic velocity $$ v_1 $$is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body. It is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the celestial body - $ R $ is the radius of the celestial body Second Cosmic Velocity (Escape Velocity) The second cosmic velocity $ v_2 $ is the minimum velocity required for an object to escape a celestial body's gravitational influence without further propulsion. It is given by: $$ v_2 = \\sqrt{2GM/R} $$ Third Cosmic Velocity The third cosmic velocity $ v_3 $ is the velocity required for an object to escape the Sun's gravitational influence from a given planet\u2019s orbit. It is given by: $$ v_3 = \\sqrt{v_2^2 + v_{orb}^2} $$ where $ v_{orb} $ is the orbital velocity of the planet around the Sun. Calculations for Earth, Mars, and Jupiter Using standard values: - Earth: $ M = 5.972 \\times 10^{24} $ kg, $ R = 6371 $ km - Mars: $ M = 6.417 \\times 10^{23} $ kg, $ R = 3389 $ km - Jupiter: $ M = 1.898 \\times 10^{27} $ kg, $ R = 69911 $ km Python Code for Graphs import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6371e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3389e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 69911e3} } # Compute velocities velocities = {} for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) velocities[body] = (v1, v2) # Plot results labels = list(velocities.keys()) v1_values = [vel[0] for vel in velocities.values()] v2_values = [vel[1] for vel in velocities.values()] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8,6)) plt.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") plt.bar(x + width/2, v2_values, width, label=\"Escape Velocity\") plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.legend() plt.title(\"First and Second Cosmic Velocities for Planets\") plt.grid(axis='y', linestyle='--', alpha=0.7) plt.show() Python Code for Animation import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(0, max(v2_values) * 1.2) line, = ax.plot([], [], 'ro', markersize=8) def update(frame): line.set_data(frame, v2_values[frame % len(v2_values)]) return line, ani = animation.FuncAnimation(fig, update, frames=len(v2_values), interval=1000, repeat=True) plt.show() Importance in Space Exploration Satellite Deployment : Understanding $ v_1 $ helps engineers design stable satellite orbits. Interplanetary Missions : Calculating $ v_2 $ ensures spacecraft can leave planetary influence. Interstellar Travel : $ v_3 $ is crucial for designing missions beyond our solar system. Solution in colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"The first cosmic velocity $$ v_1 $$is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body. It is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the celestial body - $ R $ is the radius of the celestial body","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity $ v_2 $ is the minimum velocity required for an object to escape a celestial body's gravitational influence without further propulsion. It is given by: $$ v_2 = \\sqrt{2GM/R} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"The third cosmic velocity $ v_3 $ is the velocity required for an object to escape the Sun's gravitational influence from a given planet\u2019s orbit. It is given by: $$ v_3 = \\sqrt{v_2^2 + v_{orb}^2} $$ where $ v_{orb} $ is the orbital velocity of the planet around the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"Using standard values: - Earth: $ M = 5.972 \\times 10^{24} $ kg, $ R = 6371 $ km - Mars: $ M = 6.417 \\times 10^{23} $ kg, $ R = 3389 $ km - Jupiter: $ M = 1.898 \\times 10^{27} $ kg, $ R = 69911 $ km","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-graphs","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6371e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3389e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 69911e3} } # Compute velocities velocities = {} for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) velocities[body] = (v1, v2) # Plot results labels = list(velocities.keys()) v1_values = [vel[0] for vel in velocities.values()] v2_values = [vel[1] for vel in velocities.values()] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8,6)) plt.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") plt.bar(x + width/2, v2_values, width, label=\"Escape Velocity\") plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.legend() plt.title(\"First and Second Cosmic Velocities for Planets\") plt.grid(axis='y', linestyle='--', alpha=0.7) plt.show()","title":"Python Code for Graphs"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-animation","text":"import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(0, max(v2_values) * 1.2) line, = ax.plot([], [], 'ro', markersize=8) def update(frame): line.set_data(frame, v2_values[frame % len(v2_values)]) return line, ani = animation.FuncAnimation(fig, update, frames=len(v2_values), interval=1000, repeat=True) plt.show()","title":"Python Code for Animation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Satellite Deployment : Understanding $ v_1 $ helps engineers design stable satellite orbits. Interplanetary Missions : Calculating $ v_2 $ ensures spacecraft can leave planetary influence. Interstellar Travel : $ v_3 $ is crucial for designing missions beyond our solar system. Solution in colab","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Types of Trajectories The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash. Governing Equations Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show() Python Code for Animation import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(min(x), max(x)) ax.set_ylim(min(y), max(y)) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Animated Payload Trajectory\") trajectory, = ax.plot([], [], 'r-', label='Trajectory') payload, = ax.plot([], [], 'go', markersize=8, label='Payload') def update(frame): trajectory.set_data(x[:frame], y[:frame]) payload.set_data(x[frame], y[frame]) return trajectory, payload ani = animation.FuncAnimation(fig, update, frames=len(x), interval=20, repeat=False) plt.legend() plt.show() Real-World Applications Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-animation","text":"import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(min(x), max(x)) ax.set_ylim(min(y), max(y)) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Animated Payload Trajectory\") trajectory, = ax.plot([], [], 'r-', label='Trajectory') payload, = ax.plot([], [], 'go', markersize=8, label='Payload') def update(frame): trajectory.set_data(x[:frame], y[:frame]) payload.set_data(x[frame], y[frame]) return trajectory, payload ani = animation.FuncAnimation(fig, update, frames=len(x), interval=20, repeat=False) plt.legend() plt.show()","title":"Python Code for Animation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}