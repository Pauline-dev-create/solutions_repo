{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"# Problem 1 # Theoretical Foundation Derivation from Differential Equations Projectile motion can be described using Newton\u2019s second law. Assuming no air resistance initially, the only force is gravity acting downward. Define the coordinate system with x-axis horizontal and y-axis vertical. Horizontal Motion (x-direction) No acceleration in the x-direction: \\(\\frac{d^2x}{dt^2} = 0\\) Initial velocity in x-direction: \\(v_{0x} = v_0 \\cos(\\theta)\\) Integrate: \\(\\frac{dx}{dt} = v_0 \\cos(\\theta)\\) \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) Vertical Motion (y-direction) Acceleration due to gravity \\( g = 9.8 \\, \\text{m/s}^2 \\) downward: \\(\\frac{d^2y}{dt^2} = -g\\) Initial velocity in y-direction: \\(v_{0y} = v_0 \\sin(\\theta)\\) Integrate: \\(\\frac{dy}{dt} = v_0 \\sin(\\theta) - g t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) Range Calculation The projectile hits the ground when \\( y(t) = 0 \\) : \\[ v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factor: $$ t \\left(v_0 \\sin(\\theta) - \\frac{1}{2} g t\\right) = 0 $$ Solutions: - \\( t = 0 \\) (start) - \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (time of flight) Substitute into \\( x(t) \\) to get the Range : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplify: \\[ R = \\frac{2 v_0^2 \\sin(\\theta) \\cos(\\theta)}{g} \\] Using the identity \\( \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Analysis of the Range Range vs. Angle of Projection The range formula: R = (v\u2080\u00b2 * sin(2\u03b8)) / g Maximum range occurs at \u03b8 = 45\u00b0. Example : v\u2080 = 50 m/s, \u03b8 = 45\u00b0 R = (2500 * sin(90\u00b0)) / 9.8 \u2248 255 m Other Angles : - \u03b8 = 15\u00b0 \u2192 R \u2248 91.8 m - \u03b8 = 75\u00b0 \u2192 R \u2248 163 m Effect of Initial Velocity v\u2080 (m/s) \u03b8 (\u00b0) Range (m) 30 45 91.8 40 45 163 50 45 255 Range increases with square of v\u2080. Effect of Gravitational Acceleration If g increases, range decreases (e.g., on a planet with stronger gravity). Practical Applications Sports : Optimizing the launch angle in golf, javelin, etc. Engineering : Designing projectile systems and launchers. Astrophysics : Modeling satellite launches Limitations : - Air resistance reduces range and alters trajectory - Uneven terrain or wind affects the projectile's path Implementation: Projectile Motion Simulation Plot 1: Trajectories for Different Angles (15\u00b0, 45\u00b0, 75\u00b0) at 50 m/s Below is the Python code to generate a plot similar to part (a) of the image. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # m/s^2 v0 = 50 # m/s angles = [15, 45, 75] # degrees colors = ['red', 'purple', 'green'] # Time array for simulation t_max = 2 * v0 * np.sin(np.radians(max(angles))) / g t = np.linspace(0, t_max, 1000) plt.figure(figsize=(10, 6)) for angle, color in zip(angles, colors): theta = np.radians(angle) # Positions x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Stop when y <= 0 (ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=f'Angle = {angle}\u00b0', color=color) plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show() Plot 2: Trajectories for Different Velocities (30, 40, 50 m/s) at 45\u00b0 # Constants g = 9.8 # m/s^2 v0s = [30, 40, 50] # m/s angle = 45 # degrees colors = ['red', 'purple', 'green'] # Time array t_max = 2 * max(v0s) * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, 1000) plt.figure(figsize=(10, 6)) for v0, color in zip(v0s, colors): theta = np.radians(angle) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 mask = y >= 0 plt.plot(x[mask], y[mask], label=f'v0 = {v0} m/s', color=color) plt.title('Projectile Motion for Different Velocities (Angle = 45\u00b0)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show() Plot 3: Projectile Motion With and Without Air Resistance Now, let\u2019s simulate projectile motion with air resistance. Air resistance introduces a drag force proportional to velocity: \\( F_{\\text{drag}} = -k v \\) . Differential Equations with Air Resistance \\( x \\) -direction: \\( m \\frac{d^2 x}{dt^2} = -k \\frac{dx}{dt} \\) \\( y \\) -direction: \\( m \\frac{d^2 y}{dt^2} = -mg - k \\frac{dy}{dt} \\) We\u2019ll solve these numerically using the Euler method. # Constants g = 9.8 v0 = 50 angle = 45 theta = np.radians(angle) k = 0.1 # drag coefficient m = 1 # mass in kg dt = 0.01 # time step t_max = 10 # Initial conditions vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) x, y = 0, 0 x_no_air, y_no_air = 0, 0 t = 0 # Lists to store trajectories x_traj, y_traj = [x], [y] x_no_air_traj, y_no_air_traj = [x_no_air], [y_no_air] # Euler method simulation while y >= 0 or y_no_air >= 0: # With air resistance ax = -k * vx / m ay = -g - k * vy / m vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt # Without air resistance x_no_air = v0 * np.cos(theta) * t y_no_air = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Append to trajectories if y >= 0: x_traj.append(x) y_traj.append(y) if y_no_air >= 0: x_no_air_traj.append(x_no_air) y_no_air_traj.append(y_no_air) t += dt # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air_traj, y_no_air_traj, label='No Air Resistance', color='blue') plt.plot(x_traj, y_traj, label='With Air Resistance (k = 0.1)', color='orange') plt.title('Projectile Motion: With vs. Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show() Discussion on Limitations Idealized Model : Assumes no air resistance, flat terrain, and constant gravity. Air Resistance : Reduces range and height, as shown in the plot. Conclusion This analysis demonstrates the dependence of a projectile\u2019s range on the angle of projection, with a maximum at 45\u00b0. Variations in initial velocity and air resistance significantly affect the trajectory, as visualized in the plots. These principles apply to diverse fields, from sports to engineering, though real-world factors like drag must be considered for accurate modeling. Kepler\u2019s Laws and Orbital Mechanics Solutions in Colab","title":"# Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"# Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"# Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-from-differential-equations","text":"Projectile motion can be described using Newton\u2019s second law. Assuming no air resistance initially, the only force is gravity acting downward. Define the coordinate system with x-axis horizontal and y-axis vertical.","title":"Derivation from Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"No acceleration in the x-direction: \\(\\frac{d^2x}{dt^2} = 0\\) Initial velocity in x-direction: \\(v_{0x} = v_0 \\cos(\\theta)\\) Integrate: \\(\\frac{dx}{dt} = v_0 \\cos(\\theta)\\) \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\)","title":"Horizontal Motion (x-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"Acceleration due to gravity \\( g = 9.8 \\, \\text{m/s}^2 \\) downward: \\(\\frac{d^2y}{dt^2} = -g\\) Initial velocity in y-direction: \\(v_{0y} = v_0 \\sin(\\theta)\\) Integrate: \\(\\frac{dy}{dt} = v_0 \\sin(\\theta) - g t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\)","title":"Vertical Motion (y-direction)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-calculation","text":"The projectile hits the ground when \\( y(t) = 0 \\) : \\[ v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factor: $$ t \\left(v_0 \\sin(\\theta) - \\frac{1}{2} g t\\right) = 0 $$ Solutions: - \\( t = 0 \\) (start) - \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (time of flight) Substitute into \\( x(t) \\) to get the Range : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplify: \\[ R = \\frac{2 v_0^2 \\sin(\\theta) \\cos(\\theta)}{g} \\] Using the identity \\( \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Range Calculation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-vs-angle-of-projection","text":"The range formula: R = (v\u2080\u00b2 * sin(2\u03b8)) / g Maximum range occurs at \u03b8 = 45\u00b0. Example : v\u2080 = 50 m/s, \u03b8 = 45\u00b0 R = (2500 * sin(90\u00b0)) / 9.8 \u2248 255 m Other Angles : - \u03b8 = 15\u00b0 \u2192 R \u2248 91.8 m - \u03b8 = 75\u00b0 \u2192 R \u2248 163 m","title":"Range vs. Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity","text":"v\u2080 (m/s) \u03b8 (\u00b0) Range (m) 30 45 91.8 40 45 163 50 45 255 Range increases with square of v\u2080.","title":"Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravitational-acceleration","text":"If g increases, range decreases (e.g., on a planet with stronger gravity).","title":"Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"Sports : Optimizing the launch angle in golf, javelin, etc. Engineering : Designing projectile systems and launchers. Astrophysics : Modeling satellite launches Limitations : - Air resistance reduces range and alters trajectory - Uneven terrain or wind affects the projectile's path","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-projectile-motion-simulation","text":"","title":"Implementation: Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-1-trajectories-for-different-angles-15-45-75-at-50-ms","text":"Below is the Python code to generate a plot similar to part (a) of the image. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # m/s^2 v0 = 50 # m/s angles = [15, 45, 75] # degrees colors = ['red', 'purple', 'green'] # Time array for simulation t_max = 2 * v0 * np.sin(np.radians(max(angles))) / g t = np.linspace(0, t_max, 1000) plt.figure(figsize=(10, 6)) for angle, color in zip(angles, colors): theta = np.radians(angle) # Positions x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Stop when y <= 0 (ground) mask = y >= 0 plt.plot(x[mask], y[mask], label=f'Angle = {angle}\u00b0', color=color) plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show()","title":"Plot 1: Trajectories for Different Angles (15\u00b0, 45\u00b0, 75\u00b0) at 50 m/s"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-2-trajectories-for-different-velocities-30-40-50-ms-at-45","text":"# Constants g = 9.8 # m/s^2 v0s = [30, 40, 50] # m/s angle = 45 # degrees colors = ['red', 'purple', 'green'] # Time array t_max = 2 * max(v0s) * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, 1000) plt.figure(figsize=(10, 6)) for v0, color in zip(v0s, colors): theta = np.radians(angle) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 mask = y >= 0 plt.plot(x[mask], y[mask], label=f'v0 = {v0} m/s', color=color) plt.title('Projectile Motion for Different Velocities (Angle = 45\u00b0)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show()","title":"Plot 2: Trajectories for Different Velocities (30, 40, 50 m/s) at 45\u00b0"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-3-projectile-motion-with-and-without-air-resistance","text":"Now, let\u2019s simulate projectile motion with air resistance. Air resistance introduces a drag force proportional to velocity: \\( F_{\\text{drag}} = -k v \\) .","title":"Plot 3: Projectile Motion With and Without Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#differential-equations-with-air-resistance","text":"\\( x \\) -direction: \\( m \\frac{d^2 x}{dt^2} = -k \\frac{dx}{dt} \\) \\( y \\) -direction: \\( m \\frac{d^2 y}{dt^2} = -mg - k \\frac{dy}{dt} \\) We\u2019ll solve these numerically using the Euler method. # Constants g = 9.8 v0 = 50 angle = 45 theta = np.radians(angle) k = 0.1 # drag coefficient m = 1 # mass in kg dt = 0.01 # time step t_max = 10 # Initial conditions vx = v0 * np.cos(theta) vy = v0 * np.sin(theta) x, y = 0, 0 x_no_air, y_no_air = 0, 0 t = 0 # Lists to store trajectories x_traj, y_traj = [x], [y] x_no_air_traj, y_no_air_traj = [x_no_air], [y_no_air] # Euler method simulation while y >= 0 or y_no_air >= 0: # With air resistance ax = -k * vx / m ay = -g - k * vy / m vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt # Without air resistance x_no_air = v0 * np.cos(theta) * t y_no_air = v0 * np.sin(theta) * t - 0.5 * g * t**2 # Append to trajectories if y >= 0: x_traj.append(x) y_traj.append(y) if y_no_air >= 0: x_no_air_traj.append(x_no_air) y_no_air_traj.append(y_no_air) t += dt # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air_traj, y_no_air_traj, label='No Air Resistance', color='blue') plt.plot(x_traj, y_traj, label='With Air Resistance (k = 0.1)', color='orange') plt.title('Projectile Motion: With vs. Without Air Resistance') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.legend() plt.grid(True) plt.show()","title":"Differential Equations with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion-on-limitations","text":"Idealized Model : Assumes no air resistance, flat terrain, and constant gravity. Air Resistance : Reduces range and height, as shown in the plot.","title":"Discussion on Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis demonstrates the dependence of a projectile\u2019s range on the angle of projection, with a maximum at 45\u00b0. Variations in initial velocity and air resistance significantly affect the trajectory, as visualized in the plots. These principles apply to diverse fields, from sports to engineering, though real-world factors like drag must be considered for accurate modeling. Kepler\u2019s Laws and Orbital Mechanics Solutions in Colab","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l}\\sin(\\theta) = F\\cos(\\omega_d t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration (9.81 m/s\u00b2), - \\(l\\) is the pendulum length, - \\(F\\) is the amplitude of the external driving force, - \\(\\omega_d\\) is the driving frequency, - \\(t\\) is time. Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to a linear damped-driven oscillator: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega_d t) \\] Where \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency. The general solution consists of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) . Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , with coefficients determined by substituting into the equation. The steady-state amplitude exhibits resonance when \\(\\omega_d \\approx \\omega_0\\) , maximized when \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) , amplifying energy input significantly. 2. Analysis of Dynamics Influence of Parameters Damping Coefficient $ b $ : Higher \\(b\\) reduces amplitude and prevents chaos by dissipating energy, stabilizing the system. Driving Amplitude ( \\(F\\) ) : Increasing \\(F\\) can push the system from periodic to chaotic motion, especially at specific frequencies. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance occurs; far from \\(\\omega_0\\) , quasiperiodic or chaotic behavior emerges. Transition to Chaos For large amplitudes or specific \\(\\omega_d\\) , the nonlinear \\(\\sin(\\theta)\\) term dominates, leading to chaotic motion. This is observable via phase portraits and Poincar\u00e9 sections, showing a shift from closed orbits (periodic) to scattered points (chaotic). 3. Practical Applications Energy Harvesting : Piezoelectric devices use forced oscillations to convert mechanical energy to electrical energy. Suspension Bridges : Damping and forcing model wind-induced vibrations, preventing resonance disasters (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits mirror pendulum dynamics, applicable in signal processing. 4. Implementation Different Scenarios Computational Model We use the 4th-order Runge-Kutta (RK4) method to solve the nonlinear equation numerically. Below are Python scripts for simulation, visualization, and animation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # gravity (m/s^2) l = 1.0 # length (m) b = 0.5 # damping coefficient F = 1.2 # driving amplitude omega_d = 2.0 # driving frequency omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions theta0 = 0.1 # initial angle (rad) theta_dot0 = 0.0 # initial angular velocity (rad/s) state0 = [theta0, theta_dot0] # Solve ODE solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) # Extract results theta = solution[:, 0] theta_dot = solution[:, 1] # Plotting plt.figure(figsize=(10, 6)) plt.plot(t, theta, label='Angular Displacement') plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel('Theta (rad)') plt.ylabel('Theta_dot (rad/s)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show() Animation Script import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.integrate import odeint # Parameters g = 9.81 l = 1.0 b = 0.5 F = 1.2 omega_d = 2.0 omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) state0 = [0.1, 0.0] solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) theta = solution[:, 0] # Animation setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) line, = ax.plot([], [], 'o-', lw=2) def init(): line.set_data([], []) return line, def animate(i): x = l * np.sin(theta[i]) y = -l * np.cos(theta[i]) line.set_data([0, x], [0, y]) return line, ani = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=20, blit=True) plt.title('Forced Damped Pendulum Animation') plt.grid() ani.save('pendulum_animation.mp4', writer='ffmpeg') plt.show() Solutions in colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l}\\sin(\\theta) = F\\cos(\\omega_d t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration (9.81 m/s\u00b2), - \\(l\\) is the pendulum length, - \\(F\\) is the amplitude of the external driving force, - \\(\\omega_d\\) is the driving frequency, - \\(t\\) is time.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to a linear damped-driven oscillator: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega_d t) \\] Where \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency. The general solution consists of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) . Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , with coefficients determined by substituting into the equation. The steady-state amplitude exhibits resonance when \\(\\omega_d \\approx \\omega_0\\) , maximized when \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) , amplifying energy input significantly.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-parameters","text":"Damping Coefficient $ b $ : Higher \\(b\\) reduces amplitude and prevents chaos by dissipating energy, stabilizing the system. Driving Amplitude ( \\(F\\) ) : Increasing \\(F\\) can push the system from periodic to chaotic motion, especially at specific frequencies. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance occurs; far from \\(\\omega_0\\) , quasiperiodic or chaotic behavior emerges.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"For large amplitudes or specific \\(\\omega_d\\) , the nonlinear \\(\\sin(\\theta)\\) term dominates, leading to chaotic motion. This is observable via phase portraits and Poincar\u00e9 sections, showing a shift from closed orbits (periodic) to scattered points (chaotic).","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Piezoelectric devices use forced oscillations to convert mechanical energy to electrical energy. Suspension Bridges : Damping and forcing model wind-induced vibrations, preventing resonance disasters (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits mirror pendulum dynamics, applicable in signal processing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#different-scenarios","text":"","title":"Different Scenarios"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"We use the 4th-order Runge-Kutta (RK4) method to solve the nonlinear equation numerically. Below are Python scripts for simulation, visualization, and animation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # gravity (m/s^2) l = 1.0 # length (m) b = 0.5 # damping coefficient F = 1.2 # driving amplitude omega_d = 2.0 # driving frequency omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions theta0 = 0.1 # initial angle (rad) theta_dot0 = 0.0 # initial angular velocity (rad/s) state0 = [theta0, theta_dot0] # Solve ODE solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) # Extract results theta = solution[:, 0] theta_dot = solution[:, 1] # Plotting plt.figure(figsize=(10, 6)) plt.plot(t, theta, label='Angular Displacement') plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel('Theta (rad)') plt.ylabel('Theta_dot (rad/s)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#animation-script","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.integrate import odeint # Parameters g = 9.81 l = 1.0 b = 0.5 F = 1.2 omega_d = 2.0 omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) state0 = [0.1, 0.0] solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) theta = solution[:, 0] # Animation setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) line, = ax.plot([], [], 'o-', lw=2) def init(): line.set_data([], []) return line, def animate(i): x = l * np.sin(theta[i]) y = -l * np.cos(theta[i]) line.set_data([0, x], [0, y]) return line, ani = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=20, blit=True) plt.title('Forced Damped Pendulum Animation') plt.grid() ani.save('pendulum_animation.mp4', writer='ffmpeg') plt.show() Solutions in colab","title":"Animation Script"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Orbital Radius Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship. Derivation of Kepler's Third Law for Circular Orbits For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) . Implications in Astronomy Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes. Real-World Examples 1. The Moon's Orbit Around Earth Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects). 2. Earth's Orbit Around the Sun Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit. Extension to Elliptical Orbits For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets. Computational Model Python Code for Graphing \\(T^2\\) vs \\(r^3\\) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun). Python Code for Animation of Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab Conclusion Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship.","title":"Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) .","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects).","title":"1. The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-earths-orbit-around-the-sun","text":"Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit.","title":"2. Earth's Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-graphing-t2-vs-r3","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun).","title":"Python Code for Graphing \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-animation-of-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab","title":"Python Code for Animation of Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Theoretical Foundation Definitions and Physical Meaning First Cosmic Velocity ( \\(v_1\\) ) : The minimum speed for a circular orbit at the surface of a celestial body (orbital velocity). Second Cosmic Velocity ( \\(v_2\\) ) : The escape velocity, the speed needed to escape the gravitational pull of a body entirely. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape the gravitational influence of a star system (e.g., the Sun\u2019s system for Earth), assuming the body has already escaped the planet. Derivations First Cosmic Velocity ( \\(v_1\\) ) For a circular orbit at the surface ( \\(r = R\\) , radius of the body): \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Cancel \\(m\\) and solve: \\[ v_1^2 = \\frac{G M}{R} \\quad \\Rightarrow \\quad v_1 = \\sqrt{\\frac{G M}{R}} \\] Second Cosmic Velocity ( \\(v_2\\) ) Escape velocity is derived from energy conservation: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Cancel \\(m\\) and solve: \\[ v_2^2 = \\frac{2 G M}{R} \\quad \\Rightarrow \\quad v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Note: \\(v_2 = \\sqrt{2} \\, v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) The speed to escape the Sun\u2019s gravitational influence from Earth\u2019s orbit: Earth\u2019s orbital velocity around the Sun: \\[ v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{sun}}}{R_{\\text{sun}}}} \\] Escape velocity from the Sun at Earth\u2019s orbit: \\[ v_{\\text{esc,sun}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{R_{\\text{sun}}}} = \\sqrt{2} \\, v_{\\text{orbit}} \\] The additional velocity needed from Earth\u2019s frame: \\[ v_{\\text{relative}} = v_{\\text{esc,sun}} - v_{\\text{orbit}} = (\\sqrt{2} - 1) \\sqrt{\\frac{G M_{\\text{sun}}}{R_{\\text{sun}}}} \\] From Earth\u2019s surface: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{relative}}^2} \\] For simplicity, standard \\(v_3\\) for Earth is approximately 16.6 km/s . Parameters \\(G\\) : Gravitational constant \\(= 6.6743 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body \\(M_{\\text{sun}}, R_{\\text{sun}}\\) : Mass of the Sun and distance from the Sun (for \\(v_3\\) ) Calculations for Celestial Bodies Data Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) , \\(R_{\\text{sun}} = 1.496 \\times 10^{11} \\, \\text{m}\\) Moon : \\(M = 7.342 \\times 10^{22} \\, \\text{kg}\\) , \\(R = 1.737 \\times 10^6 \\, \\text{m}\\) Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.39 \\times 10^6 \\, \\text{m}\\) Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) Sun : \\(M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) import numpy as np import matplotlib.pyplot as plt ## Constants G = 6.6743e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of Sun (kg) R_sun = 1.496e11 # Distance Earth-Sun (m) ## Celestial body data: [name, mass (kg), radius (m)] bodies = [ (\"Earth\", 5.972e24, 6.371e6), (\"Moon\", 7.342e22, 1.737e6), (\"Mars\", 6.417e23, 3.39e6), (\"Jupiter\", 1.898e27, 6.991e7) ] ## Calculate velocities v1_values = [] # First cosmic velocity (km/s) v2_values = [] # Second cosmic velocity (km/s) v3_values = [] # Third cosmic velocity (km/s, approximated) for name, M, R in bodies: # First cosmic velocity: v1 = sqrt(GM/R) v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v1_values.append(v1) # Second cosmic velocity: v2 = sqrt(2GM/R) v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s v2_values.append(v2) # Third cosmic velocity (for Earth-Sun system) if name == \"Earth\": v_orbit = np.sqrt(G * M_sun / R_sun) / 1000 # Earth\u2019s orbital velocity (km/s) v_esc_sun = np.sqrt(2 * G * M_sun / R_sun) / 1000 # Escape velocity from Sun at Earth\u2019s orbit v_relative = v_esc_sun - v_orbit # Additional velocity needed v3 = np.sqrt(v2**2 + v_relative**2) # Total velocity from Earth\u2019s surface v3_values.append(v3) else: v3_values.append(None) # Not calculated for others ## Print Earth\u2019s values print(\"Earth\u2019s Cosmic Velocities:\") print(f\"First Cosmic Velocity (v1): {v1_values[0]:.2f} km/s\") print(f\"Second Cosmic Velocity (v2): {v2_values[0]:.2f} km/s\") print(f\"Third Cosmic Velocity (v3): {v3_values[0]:.2f} km/s\") ## Visualization fig, ax = plt.subplots(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 ax.bar(x - width, v1_values, width, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, width, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + width, [v if v is not None else 0 for v in v3_values], width, label='Third Cosmic Velocity (v3)', color='red') ax.set_xticks(x) ax.set_xticklabels([body[0] for body in bodies]) ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.legend() ax.grid(True) plt.show() Results Earth\u2019s Cosmic Velocities \\(v_1\\) : \\(\\approx 7.91 \\, \\text{km/s}\\) (orbital velocity). \\(v_2\\) : \\(\\approx 11.19 \\, \\text{km/s}\\) (escape velocity). \\(v_3\\) : \\(\\approx 16.62 \\, \\text{km/s}\\) (to escape Sun\u2019s influence from Earth). Comparison Across Bodies Moon : Lower mass and radius result in smaller velocities. Mars : Intermediate values due to moderate mass and radius. Jupiter : High mass and large radius lead to significantly higher velocities. Note: \\(v_3\\) is only calculated for Earth, as it depends on the Sun\u2019s gravitational influence. Discussion Role in Space Exploration Satellites : First cosmic velocity ( \\(v_1\\) ) is critical for low Earth orbit (e.g., ~7.8 km/s for satellites). Interplanetary Missions : Second cosmic velocity ( \\(v_2\\) ) is needed to reach other planets (e.g., 11.2 km/s to leave Earth for Mars). Interstellar Travel : Third cosmic velocity ( \\(v_3\\) ) sets the threshold for leaving the Solar System (e.g., Voyager 1 exceeded this). Factors Affecting Velocities Mass ( \\(M\\) ) : Higher mass increases velocities. Radius ( \\(R\\) ) : Larger radius decreases velocities. Distance to Star ( \\(R_{\\text{sun}}\\) ) : Affects \\(v_3\\) . Conclusion Understanding cosmic velocities enables space exploration \u2014 from satellite launches to interstellar probes \u2014 by quantifying the energy needed to overcome gravitational forces. Solution in colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity ( \\(v_1\\) ) : The minimum speed for a circular orbit at the surface of a celestial body (orbital velocity). Second Cosmic Velocity ( \\(v_2\\) ) : The escape velocity, the speed needed to escape the gravitational pull of a body entirely. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape the gravitational influence of a star system (e.g., the Sun\u2019s system for Earth), assuming the body has already escaped the planet.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations","text":"","title":"Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"For a circular orbit at the surface ( \\(r = R\\) , radius of the body): \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Cancel \\(m\\) and solve: \\[ v_1^2 = \\frac{G M}{R} \\quad \\Rightarrow \\quad v_1 = \\sqrt{\\frac{G M}{R}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"Escape velocity is derived from energy conservation: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Cancel \\(m\\) and solve: \\[ v_2^2 = \\frac{2 G M}{R} \\quad \\Rightarrow \\quad v_2 = \\sqrt{\\frac{2 G M}{R}} \\] Note: \\(v_2 = \\sqrt{2} \\, v_1\\) .","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The speed to escape the Sun\u2019s gravitational influence from Earth\u2019s orbit: Earth\u2019s orbital velocity around the Sun: \\[ v_{\\text{orbit}} = \\sqrt{\\frac{G M_{\\text{sun}}}{R_{\\text{sun}}}} \\] Escape velocity from the Sun at Earth\u2019s orbit: \\[ v_{\\text{esc,sun}} = \\sqrt{\\frac{2 G M_{\\text{sun}}}{R_{\\text{sun}}}} = \\sqrt{2} \\, v_{\\text{orbit}} \\] The additional velocity needed from Earth\u2019s frame: \\[ v_{\\text{relative}} = v_{\\text{esc,sun}} - v_{\\text{orbit}} = (\\sqrt{2} - 1) \\sqrt{\\frac{G M_{\\text{sun}}}{R_{\\text{sun}}}} \\] From Earth\u2019s surface: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{relative}}^2} \\] For simplicity, standard \\(v_3\\) for Earth is approximately 16.6 km/s .","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters","text":"\\(G\\) : Gravitational constant \\(= 6.6743 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) \\(M\\) : Mass of the celestial body \\(R\\) : Radius of the celestial body \\(M_{\\text{sun}}, R_{\\text{sun}}\\) : Mass of the Sun and distance from the Sun (for \\(v_3\\) )","title":"Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-celestial-bodies","text":"","title":"Calculations for Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#data","text":"Earth : \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) , \\(R = 6.371 \\times 10^6 \\, \\text{m}\\) , \\(R_{\\text{sun}} = 1.496 \\times 10^{11} \\, \\text{m}\\) Moon : \\(M = 7.342 \\times 10^{22} \\, \\text{kg}\\) , \\(R = 1.737 \\times 10^6 \\, \\text{m}\\) Mars : \\(M = 6.417 \\times 10^{23} \\, \\text{kg}\\) , \\(R = 3.39 \\times 10^6 \\, \\text{m}\\) Jupiter : \\(M = 1.898 \\times 10^{27} \\, \\text{kg}\\) , \\(R = 6.991 \\times 10^7 \\, \\text{m}\\) Sun : \\(M_{\\text{sun}} = 1.989 \\times 10^{30} \\, \\text{kg}\\) import numpy as np import matplotlib.pyplot as plt ## Constants G = 6.6743e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of Sun (kg) R_sun = 1.496e11 # Distance Earth-Sun (m) ## Celestial body data: [name, mass (kg), radius (m)] bodies = [ (\"Earth\", 5.972e24, 6.371e6), (\"Moon\", 7.342e22, 1.737e6), (\"Mars\", 6.417e23, 3.39e6), (\"Jupiter\", 1.898e27, 6.991e7) ] ## Calculate velocities v1_values = [] # First cosmic velocity (km/s) v2_values = [] # Second cosmic velocity (km/s) v3_values = [] # Third cosmic velocity (km/s, approximated) for name, M, R in bodies: # First cosmic velocity: v1 = sqrt(GM/R) v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v1_values.append(v1) # Second cosmic velocity: v2 = sqrt(2GM/R) v2 = np.sqrt(2 * G * M / R) / 1000 # Convert to km/s v2_values.append(v2) # Third cosmic velocity (for Earth-Sun system) if name == \"Earth\": v_orbit = np.sqrt(G * M_sun / R_sun) / 1000 # Earth\u2019s orbital velocity (km/s) v_esc_sun = np.sqrt(2 * G * M_sun / R_sun) / 1000 # Escape velocity from Sun at Earth\u2019s orbit v_relative = v_esc_sun - v_orbit # Additional velocity needed v3 = np.sqrt(v2**2 + v_relative**2) # Total velocity from Earth\u2019s surface v3_values.append(v3) else: v3_values.append(None) # Not calculated for others ## Print Earth\u2019s values print(\"Earth\u2019s Cosmic Velocities:\") print(f\"First Cosmic Velocity (v1): {v1_values[0]:.2f} km/s\") print(f\"Second Cosmic Velocity (v2): {v2_values[0]:.2f} km/s\") print(f\"Third Cosmic Velocity (v3): {v3_values[0]:.2f} km/s\") ## Visualization fig, ax = plt.subplots(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 ax.bar(x - width, v1_values, width, label='First Cosmic Velocity (v1)', color='blue') ax.bar(x, v2_values, width, label='Second Cosmic Velocity (v2)', color='green') ax.bar(x + width, [v if v is not None else 0 for v in v3_values], width, label='Third Cosmic Velocity (v3)', color='red') ax.set_xticks(x) ax.set_xticklabels([body[0] for body in bodies]) ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.legend() ax.grid(True) plt.show()","title":"Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results","text":"","title":"Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earths-cosmic-velocities","text":"\\(v_1\\) : \\(\\approx 7.91 \\, \\text{km/s}\\) (orbital velocity). \\(v_2\\) : \\(\\approx 11.19 \\, \\text{km/s}\\) (escape velocity). \\(v_3\\) : \\(\\approx 16.62 \\, \\text{km/s}\\) (to escape Sun\u2019s influence from Earth).","title":"Earth\u2019s Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-across-bodies","text":"Moon : Lower mass and radius result in smaller velocities. Mars : Intermediate values due to moderate mass and radius. Jupiter : High mass and large radius lead to significantly higher velocities. Note: \\(v_3\\) is only calculated for Earth, as it depends on the Sun\u2019s gravitational influence.","title":"Comparison Across Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#role-in-space-exploration","text":"Satellites : First cosmic velocity ( \\(v_1\\) ) is critical for low Earth orbit (e.g., ~7.8 km/s for satellites). Interplanetary Missions : Second cosmic velocity ( \\(v_2\\) ) is needed to reach other planets (e.g., 11.2 km/s to leave Earth for Mars). Interstellar Travel : Third cosmic velocity ( \\(v_3\\) ) sets the threshold for leaving the Solar System (e.g., Voyager 1 exceeded this).","title":"Role in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#factors-affecting-velocities","text":"Mass ( \\(M\\) ) : Higher mass increases velocities. Radius ( \\(R\\) ) : Larger radius decreases velocities. Distance to Star ( \\(R_{\\text{sun}}\\) ) : Affects \\(v_3\\) .","title":"Factors Affecting Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding cosmic velocities enables space exploration \u2014 from satellite launches to interstellar probes \u2014 by quantifying the energy needed to overcome gravitational forces. Solution in colab","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Types of Trajectories The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash. Governing Equations Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint ## Constants G = 6.6743e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) r0 = R + 400e3 # Initial radius (m, 400 km altitude) ## Escape velocity at r0 v_esc = np.sqrt(2 * G * M / r0) / 1000 # km/s print(f\"Escape Velocity at 400 km: {v_esc:.2f} km/s\") ## Differential equations def gravity_motion(state, t, G, M): x, vx, y, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] ## Time array t = np.linspace(0, 10000, 1000) # 10,000 seconds ## Initial conditions: Start at (r0, 0) with different tangential velocities scenarios = [ (\"Trajectory 1 (Elliptical)\", 7.5e3, 'b'), # Below escape, circular orbit speed (\"Trajectory 2 (Elliptical)\", 8.0e3, 'r'), # Slightly eccentric orbit (\"Trajectory 3 (Parabolic)\", 10.9e3, 'g'), # Near escape velocity (\"Trajectory 4 (Hyperbolic)\", 12.0e3, 'm') # Above escape velocity ] ## Simulate trajectories trajectories = [] for _, v, _ in scenarios: state0 = [r0, 0, 0, v] # (x, vx, y, vy) solution = odeint(gravity_motion, state0, t, args=(G, M)) trajectories.append(solution) ## Plotting (similar to the provided image) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6)) # Plot Earth as a filled circle earth = plt.Circle((0, 0), R, color='blue', label='Earth') for ax in [ax1, ax2]: ax.add_patch(plt.Circle((0, 0), R, color='blue', label='Earth')) ax.plot(0, 0, 'yo', label='Center of Earth') # Center point ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.grid(True) ax.set_aspect('equal') ## Plot trajectories (Case 1: Zoomed out) ax1.set_title('Trajectories in a Gravitational Field (Zoomed Out)') for i, (label, _, color) in enumerate(scenarios): x, y = trajectories[i][:, 0], trajectories[i][:, 2] ax1.plot(x, y, color=color, label=label) ax1.legend() ## Plot trajectories (Case 2: Zoomed in) ax2.set_title('Trajectories in a Gravitational Field (Zoomed In)') for i, (label, _, color) in enumerate(scenarios): x, y = trajectories[i][:, 0], trajectories[i][:, 2] ax2.plot(x, y, color=color, label=label) ## Adjust limits for zoomed-in view zoom_factor = 1.5 * R ax2.set_xlim(-zoom_factor, zoom_factor) ax2.set_ylim(-zoom_factor, zoom_factor) ax2.legend() plt.tight_layout() plt.show() Real-World Applications Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint ## Constants G = 6.6743e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) r0 = R + 400e3 # Initial radius (m, 400 km altitude) ## Escape velocity at r0 v_esc = np.sqrt(2 * G * M / r0) / 1000 # km/s print(f\"Escape Velocity at 400 km: {v_esc:.2f} km/s\") ## Differential equations def gravity_motion(state, t, G, M): x, vx, y, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, ax, vy, ay] ## Time array t = np.linspace(0, 10000, 1000) # 10,000 seconds ## Initial conditions: Start at (r0, 0) with different tangential velocities scenarios = [ (\"Trajectory 1 (Elliptical)\", 7.5e3, 'b'), # Below escape, circular orbit speed (\"Trajectory 2 (Elliptical)\", 8.0e3, 'r'), # Slightly eccentric orbit (\"Trajectory 3 (Parabolic)\", 10.9e3, 'g'), # Near escape velocity (\"Trajectory 4 (Hyperbolic)\", 12.0e3, 'm') # Above escape velocity ] ## Simulate trajectories trajectories = [] for _, v, _ in scenarios: state0 = [r0, 0, 0, v] # (x, vx, y, vy) solution = odeint(gravity_motion, state0, t, args=(G, M)) trajectories.append(solution) ## Plotting (similar to the provided image) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6)) # Plot Earth as a filled circle earth = plt.Circle((0, 0), R, color='blue', label='Earth') for ax in [ax1, ax2]: ax.add_patch(plt.Circle((0, 0), R, color='blue', label='Earth')) ax.plot(0, 0, 'yo', label='Center of Earth') # Center point ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.grid(True) ax.set_aspect('equal') ## Plot trajectories (Case 1: Zoomed out) ax1.set_title('Trajectories in a Gravitational Field (Zoomed Out)') for i, (label, _, color) in enumerate(scenarios): x, y = trajectories[i][:, 0], trajectories[i][:, 2] ax1.plot(x, y, color=color, label=label) ax1.legend() ## Plot trajectories (Case 2: Zoomed in) ax2.set_title('Trajectories in a Gravitational Field (Zoomed In)') for i, (label, _, color) in enumerate(scenarios): x, y = trajectories[i][:, 0], trajectories[i][:, 2] ax2.plot(x, y, color=color, label=label) ## Adjust limits for zoomed-in view zoom_factor = 1.5 * R ax2.set_xlim(-zoom_factor, zoom_factor) ax2.set_ylim(-zoom_factor, zoom_factor) ax2.legend() plt.tight_layout() plt.show()","title":"Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Fundamentals of Waves Amplitude (A) : The maximum displacement from equilibrium. Wavelength $$ \\lambda $$ The distance between successive crests. **Wave number $$ k \\( \\(**\\) \\) k = \\frac{2\\pi}{\\lambda} $$ Frequency (f) : The number of oscillations per unit time. Angular frequency $$ \\omega $$ $$ \\omega = 2\\pi f $$ Phase $$ \\phi $$ Describes the wave's shift at a point. A single disturbance from a point source is modeled as \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] where $$ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} $$ is the distance from the $$ i $$-th source to point $$ (x, y) $$ The total displacement at point $$ (x, y) $$ is: \\[ U(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi) \\] Numerical Parameters and Calculations Let's assume the following values: - Amplitude: $$ A = 1.0 $$ - Wavelength: $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{1} = 6.2832 $$ - Frequency: $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ - Initial Phase: $$ \\phi = 0 $$ - Radius of the polygon: 3 units Each wave source is described by: \\[ u_i(x, y, t) = \\cos(6.2832 \\cdot r_i - 6.2832 \\cdot t) \\] where $$ r_i $$ is the distance from each source at the vertex of the pentagon. The resulting wave field is the sum of all five such terms. Python Code import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Define the regular polygon (pentagon) def regular_polygon(n_sides, radius=3): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] sources = regular_polygon(5) # 5 for pentagon # Define the grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) # Superposition function def wave_interference(x, y, sources, t): result = np.zeros_like(x) for (x0, y0) in sources: r = np.sqrt((x - x0)**2 + (y - y0)**2) result += A * np.cos(k * r - omega * t + phi) return result # Static Plot at t = 0 Z = wave_interference(X, Y, sources, 0) plt.figure(figsize=(8, 8)) plt.contourf(X, Y, Z, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Water Surface Interference Pattern - Regular Pentagon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import Image, display Set up the grid grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) Wave parameters wavelength = 1.0 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency for time evolution Initialize the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_title('Wave Propagation Animation') Initial wave field (at t=0) r = np.sqrt(X 2 + Y 2) Z = np.sin(k * r) / (r + 1e-10) # Avoid division by zero at the center im = ax.imshow(Z, cmap='RdBu', extent=[-5, 5, -5, 5], vmin=-0.5, vmax=0.5) plt.colorbar(im, ax=ax, label='Amplitude') Animation update function def update(frame): t = frame * 0.05 # Time step Z = np.sin(k * r - omega * t) / (r + 1e-10) # Time-evolving wave im.set_array(Z) return [im] Create the animation frames = 100 # Number of frames in the GIF ani = animation.FuncAnimation(fig, update, frames=frames, interval=50, blit=True) Save the animation as a GIF gif_path = 'wave_propagation.gif' ani.save(gif_path, writer='pillow') Display the GIF in Colab plt.close(fig) # Close the figure to avoid static display display(Image(filename=gif_path)) Visuals in google colab Observations Constructive Interference : Bright/red regions where waves reinforce. Destructive Interference : Dark/blue regions where waves cancel. Numerical Parameters and Calculations Amplitude : $$ A = 1.0 $$ Wavelength : $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{1.0} = 6.2832 $$ Frequency : $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ Initial Phase : $$ \\phi = 0 $$ Polygon Radius : $$ R = 3 $$ units (distance from center to each vertex) Step-by-Step Example Let\u2019s compute the displacement at point $$ (x, y) = (0, 0) $$ at time $$ t = 0 $$ from one source located at $$ (x_1, y_1) = (3, 0) $$ (one vertex of the pentagon): Distance from source : $$ r_1 = \\sqrt{(x - x_1)^2 + (y - y_1)^2} = \\sqrt{(0 - 3)^2 + (0 - 0)^2} = 3 $$ Wave contribution from that source : $$ u_1 = A \\cos(k r_1 - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 6.2832 \\cdot 0 + 0) = \\cos(18.8496) \\approx -1 $$ all 5 vertices, and sum: $$ U(0, 0, 0) = \\sum_{i=1}^{5} \\cos(6.2832 \\cdot r_i) $$ wave contributions from each of the 5 pentagon vertices to the point at the center of the polygon, i.e., $ (x, y) = (0, 0) $, at time $ t = 0 $. Step-by-Step Calculation at Point (0, 0), Time $t = 0 $ Amplitude $ A = 1.0 $ Wavelength $ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = 6.2832 $ Frequency $ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $ Phase $ \\phi = 0 $ Radius of pentagon: $ R = 3 $ Vertex Coordinates of Pentagon The 5 vertices of a regular pentagon centered at the origin, with radius 3 units: Vertex $ x_i $ $ y_i $ 1 $ 3.0000 $ $ 0.0000 $ 2 $ 0.9270 $ $ 2.8532 $ 3 $ -2.4271 $ $ 1.7634 $ 4 $ -2.4271 $ $ -1.7634 $ 5 $ 0.9270 $ $ -2.8532 $ Distance to (0, 0) from Each Vertex: We compute: $$ r_i = \\sqrt{x_i^2 + y_i^2} $$ Since all points are exactly 3 units from the center, we have: \\( \\(r_1 = r_2 = r_3 = r_4 = r_5 = 3\\) \\) Wave Contribution from Each Source Using: \\[ u_i = \\cos(k r_i - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 0 + 0) = \\cos(18.8496)\\] \\[ \\cos(18.8496) \\approx \\cos(6\\pi) = 1.0 \\] So each of the five wave contributions is 1.0 at that moment. Final Total Displacement at (0, 0), \\( t = 0 \\) : \\[ U(0, 0, 0) = \\sum_{i=1}^{5} u_i = 5 \\cdot 1.0 = \\boxed{5.0} \\] Summary Table Vertex Coordinates (x, y) Distance 4 r_i $ $u_i = \\cos(k r_i) $ 1 (3.0000, 0.0000) 3.0000 1.0 2 (0.9270, 2.8532) 3.0000 1.0 3 (-2.4271, 1.7634) 3.0000 1.0 4 (-2.4271, -1.7634) 3.0000 1.0 5 (0.9270, -2.8532) 3.0000 1.0 Total Displacement 5.0","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a Water Surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#fundamentals-of-waves","text":"Amplitude (A) : The maximum displacement from equilibrium. Wavelength $$ \\lambda $$ The distance between successive crests. **Wave number $$ k \\( \\(**\\) \\) k = \\frac{2\\pi}{\\lambda} $$ Frequency (f) : The number of oscillations per unit time. Angular frequency $$ \\omega $$ $$ \\omega = 2\\pi f $$ Phase $$ \\phi $$ Describes the wave's shift at a point. A single disturbance from a point source is modeled as \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] where $$ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} $$ is the distance from the $$ i $$-th source to point $$ (x, y) $$ The total displacement at point $$ (x, y) $$ is: \\[ U(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi) \\]","title":"Fundamentals of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#numerical-parameters-and-calculations","text":"Let's assume the following values: - Amplitude: $$ A = 1.0 $$ - Wavelength: $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{1} = 6.2832 $$ - Frequency: $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ - Initial Phase: $$ \\phi = 0 $$ - Radius of the polygon: 3 units Each wave source is described by: \\[ u_i(x, y, t) = \\cos(6.2832 \\cdot r_i - 6.2832 \\cdot t) \\] where $$ r_i $$ is the distance from each source at the vertex of the pentagon. The resulting wave field is the sum of all five such terms.","title":"Numerical Parameters and Calculations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Define the regular polygon (pentagon) def regular_polygon(n_sides, radius=3): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] sources = regular_polygon(5) # 5 for pentagon # Define the grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) # Superposition function def wave_interference(x, y, sources, t): result = np.zeros_like(x) for (x0, y0) in sources: r = np.sqrt((x - x0)**2 + (y - y0)**2) result += A * np.cos(k * r - omega * t + phi) return result # Static Plot at t = 0 Z = wave_interference(X, Y, sources, 0) plt.figure(figsize=(8, 8)) plt.contourf(X, Y, Z, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Water Surface Interference Pattern - Regular Pentagon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib import animation from IPython.display import Image, display Set up the grid grid_size = 100 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) Wave parameters wavelength = 1.0 k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency for time evolution Initialize the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_title('Wave Propagation Animation') Initial wave field (at t=0) r = np.sqrt(X 2 + Y 2) Z = np.sin(k * r) / (r + 1e-10) # Avoid division by zero at the center im = ax.imshow(Z, cmap='RdBu', extent=[-5, 5, -5, 5], vmin=-0.5, vmax=0.5) plt.colorbar(im, ax=ax, label='Amplitude') Animation update function def update(frame): t = frame * 0.05 # Time step Z = np.sin(k * r - omega * t) / (r + 1e-10) # Time-evolving wave im.set_array(Z) return [im] Create the animation frames = 100 # Number of frames in the GIF ani = animation.FuncAnimation(fig, update, frames=frames, interval=50, blit=True) Save the animation as a GIF gif_path = 'wave_propagation.gif' ani.save(gif_path, writer='pillow') Display the GIF in Colab plt.close(fig) # Close the figure to avoid static display display(Image(filename=gif_path)) Visuals in google colab","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Constructive Interference : Bright/red regions where waves reinforce. Destructive Interference : Dark/blue regions where waves cancel.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#numerical-parameters-and-calculations_1","text":"Amplitude : $$ A = 1.0 $$ Wavelength : $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{1.0} = 6.2832 $$ Frequency : $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ Initial Phase : $$ \\phi = 0 $$ Polygon Radius : $$ R = 3 $$ units (distance from center to each vertex)","title":"Numerical Parameters and Calculations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-example","text":"Let\u2019s compute the displacement at point $$ (x, y) = (0, 0) $$ at time $$ t = 0 $$ from one source located at $$ (x_1, y_1) = (3, 0) $$ (one vertex of the pentagon): Distance from source : $$ r_1 = \\sqrt{(x - x_1)^2 + (y - y_1)^2} = \\sqrt{(0 - 3)^2 + (0 - 0)^2} = 3 $$ Wave contribution from that source : $$ u_1 = A \\cos(k r_1 - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 6.2832 \\cdot 0 + 0) = \\cos(18.8496) \\approx -1 $$","title":"Step-by-Step Example"},{"location":"1%20Physics/3%20Waves/Problem_1/#all-5-vertices-and-sum","text":"$$ U(0, 0, 0) = \\sum_{i=1}^{5} \\cos(6.2832 \\cdot r_i) $$ wave contributions from each of the 5 pentagon vertices to the point at the center of the polygon, i.e., $ (x, y) = (0, 0) $, at time $ t = 0 $.","title":"all 5 vertices, and sum:"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-calculation-at-point-0-0-time-t-0","text":"Amplitude $ A = 1.0 $ Wavelength $ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = 6.2832 $ Frequency $ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $ Phase $ \\phi = 0 $ Radius of pentagon: $ R = 3 $","title":"Step-by-Step Calculation at Point (0, 0), Time $t = 0 $"},{"location":"1%20Physics/3%20Waves/Problem_1/#vertex-coordinates-of-pentagon","text":"The 5 vertices of a regular pentagon centered at the origin, with radius 3 units: Vertex $ x_i $ $ y_i $ 1 $ 3.0000 $ $ 0.0000 $ 2 $ 0.9270 $ $ 2.8532 $ 3 $ -2.4271 $ $ 1.7634 $ 4 $ -2.4271 $ $ -1.7634 $ 5 $ 0.9270 $ $ -2.8532 $","title":"Vertex Coordinates of Pentagon"},{"location":"1%20Physics/3%20Waves/Problem_1/#distance-to-0-0-from-each-vertex","text":"We compute: $$ r_i = \\sqrt{x_i^2 + y_i^2} $$ Since all points are exactly 3 units from the center, we have:","title":"Distance to (0, 0) from Each Vertex:"},{"location":"1%20Physics/3%20Waves/Problem_1/#r_1-r_2-r_3-r_4-r_5-3","text":"","title":"\\(\\(r_1 = r_2 = r_3 = r_4 = r_5 = 3\\)\\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-contribution-from-each-source","text":"Using: \\[ u_i = \\cos(k r_i - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 0 + 0) = \\cos(18.8496)\\] \\[ \\cos(18.8496) \\approx \\cos(6\\pi) = 1.0 \\] So each of the five wave contributions is 1.0 at that moment.","title":"Wave Contribution from Each Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#final-total-displacement-at-0-0-t-0","text":"\\[ U(0, 0, 0) = \\sum_{i=1}^{5} u_i = 5 \\cdot 1.0 = \\boxed{5.0} \\]","title":"Final Total Displacement at (0, 0), \\( t = 0 \\):"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary-table","text":"Vertex Coordinates (x, y) Distance 4 r_i $ $u_i = \\cos(k r_i) $ 1 (3.0000, 0.0000) 3.0000 1.0 2 (0.9270, 2.8532) 3.0000 1.0 3 (-2.4271, 1.7634) 3.0000 1.0 4 (-2.4271, -1.7634) 3.0000 1.0 5 (0.9270, -2.8532) 3.0000 1.0 Total Displacement 5.0","title":"Summary Table"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Fundamentals of the Lorentz Force Lorentz Force and Charged Particle Motion \\[ \\mathbf{F} = q\\mathbf{E} + q(\\mathbf{v} \\times \\mathbf{B}) \\] Electric Force : $$ q\\mathbf{E} $$ Causes linear acceleration . Magnetic Force : $$ q(\\mathbf{v} \\times \\mathbf{B}) $$ Acts perpendicular to both velocity and magnetic field, causing circular or helical motion . Motion Characteristics Uniform Magnetic Field ( \\(\\mathbf{B}\\) ): Circular or helical path. Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Uniform Electric Field ( \\(\\mathbf{E}\\) ): Causes linear acceleration in the direction of \\(\\mathbf{E}\\) . Crossed Electric and Magnetic Fields ( \\(\\mathbf{E} \\perp \\mathbf{B}\\) ): Results in drift velocity : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ For \\(\\mathbf{E} = E\\hat{y}\\) and \\(\\mathbf{B} = B\\hat{z}\\) : $$ \\mathbf{v}_d = \\frac{E}{B} \\hat{x} $$ Numerical Solution (Euler Method) Use the Euler method to update particle position and velocity: Acceleration: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Velocity Update: $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a} \\Delta t $$ Position Update: $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$ Applications Particle Accelerators : Magnetic fields bend paths (e.g., cyclotrons). Electric fields accelerate particles. Mass Spectrometers : Magnetic fields separate ions by mass-to-charge ratio using circular paths. Plasma Confinement : Magnetic fields trap particles in fusion devices (e.g., tokamaks ). Simulation Scenarios Uniform Magnetic Field : $$ \\mathbf{B} = B\\hat{z} $$ Combined Electric and Magnetic Fields : $$ \\mathbf{E} = E\\hat{x}, \\quad \\mathbf{B} = B\\hat{z} $$ Crossed Fields : $$ \\mathbf{E} = E\\hat{y}, \\quad \\mathbf{B} = B\\hat{z} $$ import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D Constants q = 1.6e-19 # Charge (Coulombs, e.g., electron) m = 9.1e-31 # Mass (kg, e.g., electron) dt = 1e-9 # Time step (seconds) steps = 1000 # Number of steps Lorentz force function def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) / m Simulation function def simulate_trajectory(v0, E, B, steps=steps, dt=dt): r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array v[0] = v0 # Initial velocity for i in range(steps-1): a = lorentz_force(v[i], E, B) v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i] * dt return r, v Field configurations B_z = 0.1 # Magnetic field strength (Tesla) E_x = 1e5 # Electric field strength (V/m) Scenario 1: Uniform magnetic field (B along z) v0_1 = np.array([1e6, 0, 0]) # Initial velocity in x-direction E_1 = np.array([0, 0, 0]) # No electric field B_1 = np.array([0, 0, B_z]) # B in z-direction r_1, v_1 = simulate_trajectory(v0_1, E_1, B_1) Scenario 2: Combined E and B fields v0_2 = np.array([1e6, 0, 1e6]) # Velocity in x and z E_2 = np.array([E_x, 0, 0]) # E in x-direction B_2 = np.array([0, 0, B_z]) # B in z-direction r_2, v_2 = simulate_trajectory(v0_2, E_2, B_2) Scenario 3: Crossed E and B fields v0_3 = np.array([0, 0, 0]) # No initial velocity E_3 = np.array([0, E_x, 0]) # E in y-direction B_3 = np.array([0, 0, B_z]) # B in z-direction r_3, v_3 = simulate_trajectory(v0_3, E_3, B_3) Visualization fig = plt.figure(figsize=(18, 5)) Scenario 1: 2D Plot (xy-plane, circular motion) ax1 = fig.add_subplot(131) ax1.plot(r_1[:, 0], r_1[:, 1], 'b-', label='Trajectory') ax1.set_xlabel('x (m)') ax1.set_ylabel('y (m)') ax1.set_title('Uniform B Field (Circular Motion)') ax1.grid(True) ax1.legend() ax1.set_aspect('equal') Scenario 2: 3D Plot (helical motion with E-field) ax2 = fig.add_subplot(132, projection='3d') ax2.plot(r_2[:, 0], r_2[:, 1], r_2[:, 2], 'g-', label='Trajectory') ax2.set_xlabel('x (m)') ax2.set_ylabel('y (m)') ax2.set_zlabel('z (m)') ax2.set_title('Combined E and B Fields (Helical)') ax2.legend() Scenario 3: 2D Plot (xy-plane, drift motion) ax3 = fig.add_subplot(133) ax3.plot(r_3[:, 0], r_3[:, 1], 'r-', label='Trajectory') ax3.set_xlabel('x (m)') ax3.set_ylabel('y (m)') ax3.set_title('Crossed E and B Fields (Drift)') ax3.grid(True) ax3.legend() ax3.set_aspect('equal') plt.tight_layout() plt.show() Charged particle motion under the Lorentz Force, covering: Circular motion (uniform magnetic field), Helical motion (velocity with component along \ud835\udc35B), E\u00d7B drift (crossed fields). Visuals in colab Results and Visualizations The script simulates the following three scenarios: 1. Uniform Magnetic Field Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (10^6, 0, 0) \\ \\text{m/s} $$ Result : Circular motion in the xy-plane due to Lorentz force. Observation : Larmor radius is visible and consistent with theory. 2. Combined Electric and Magnetic Fields Electric field: $$ \\mathbf{E} = (10^5, 0, 0) \\ \\text{V/m} $$ Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (10^6, 0, 10^6) \\ \\text{m/s} $$ Result : Helical motion with linear acceleration along the x-axis due to the electric field. 3. Crossed Electric and Magnetic Fields Electric field: $$ \\mathbf{E} = (0, 10^5, 0) \\ \\text{V/m} $$ Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (0, 0, 0) \\ \\text{m/s} $$ Result : Uniform drift in the x-direction. Theoretical drift velocity : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} = \\left(\\frac{E}{B}, 0, 0\\right) = (10^6, 0, 0) \\ \\text{m/s} $$ Key Phenomena Larmor Radius : $$ r_L = \\frac{m v_\\perp}{|q| B} $$ Observed in Scenario 1 as the radius of the circular path in the xy-plane. Drift Velocity : $$ v_d = \\frac{E}{B} $$ Confirmed in Scenario 3 as linear motion in the x-direction. . Conclusion These simulations illustrate the Lorentz force\u2019s role in controlling charged particle motion, bridging theory to applications like accelerators and plasma confinement.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#fundamentals-of-the-lorentz-force","text":"","title":"Fundamentals of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-and-charged-particle-motion","text":"\\[ \\mathbf{F} = q\\mathbf{E} + q(\\mathbf{v} \\times \\mathbf{B}) \\] Electric Force : $$ q\\mathbf{E} $$ Causes linear acceleration . Magnetic Force : $$ q(\\mathbf{v} \\times \\mathbf{B}) $$ Acts perpendicular to both velocity and magnetic field, causing circular or helical motion .","title":"Lorentz Force and Charged Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motion-characteristics","text":"Uniform Magnetic Field ( \\(\\mathbf{B}\\) ): Circular or helical path. Larmor radius : $$ r_L = \\frac{mv_\\perp}{|q|B} $$ Uniform Electric Field ( \\(\\mathbf{E}\\) ): Causes linear acceleration in the direction of \\(\\mathbf{E}\\) . Crossed Electric and Magnetic Fields ( \\(\\mathbf{E} \\perp \\mathbf{B}\\) ): Results in drift velocity : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ For \\(\\mathbf{E} = E\\hat{y}\\) and \\(\\mathbf{B} = B\\hat{z}\\) : $$ \\mathbf{v}_d = \\frac{E}{B} \\hat{x} $$","title":"Motion Characteristics"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-solution-euler-method","text":"Use the Euler method to update particle position and velocity: Acceleration: $$ \\mathbf{a} = \\frac{\\mathbf{F}}{m} $$ Velocity Update: $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a} \\Delta t $$ Position Update: $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$","title":"Numerical Solution (Euler Method)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications","text":"Particle Accelerators : Magnetic fields bend paths (e.g., cyclotrons). Electric fields accelerate particles. Mass Spectrometers : Magnetic fields separate ions by mass-to-charge ratio using circular paths. Plasma Confinement : Magnetic fields trap particles in fusion devices (e.g., tokamaks ).","title":"Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-scenarios","text":"Uniform Magnetic Field : $$ \\mathbf{B} = B\\hat{z} $$ Combined Electric and Magnetic Fields : $$ \\mathbf{E} = E\\hat{x}, \\quad \\mathbf{B} = B\\hat{z} $$ Crossed Fields : $$ \\mathbf{E} = E\\hat{y}, \\quad \\mathbf{B} = B\\hat{z} $$ import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D","title":"Simulation Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants","text":"q = 1.6e-19 # Charge (Coulombs, e.g., electron) m = 9.1e-31 # Mass (kg, e.g., electron) dt = 1e-9 # Time step (seconds) steps = 1000 # Number of steps","title":"Constants"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-function","text":"def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) / m","title":"Lorentz force function"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-function","text":"def simulate_trajectory(v0, E, B, steps=steps, dt=dt): r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array v[0] = v0 # Initial velocity for i in range(steps-1): a = lorentz_force(v[i], E, B) v[i+1] = v[i] + a * dt r[i+1] = r[i] + v[i] * dt return r, v","title":"Simulation function"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#field-configurations","text":"B_z = 0.1 # Magnetic field strength (Tesla) E_x = 1e5 # Electric field strength (V/m)","title":"Field configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-1-uniform-magnetic-field-b-along-z","text":"v0_1 = np.array([1e6, 0, 0]) # Initial velocity in x-direction E_1 = np.array([0, 0, 0]) # No electric field B_1 = np.array([0, 0, B_z]) # B in z-direction r_1, v_1 = simulate_trajectory(v0_1, E_1, B_1)","title":"Scenario 1: Uniform magnetic field (B along z)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-2-combined-e-and-b-fields","text":"v0_2 = np.array([1e6, 0, 1e6]) # Velocity in x and z E_2 = np.array([E_x, 0, 0]) # E in x-direction B_2 = np.array([0, 0, B_z]) # B in z-direction r_2, v_2 = simulate_trajectory(v0_2, E_2, B_2)","title":"Scenario 2: Combined E and B fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-3-crossed-e-and-b-fields","text":"v0_3 = np.array([0, 0, 0]) # No initial velocity E_3 = np.array([0, E_x, 0]) # E in y-direction B_3 = np.array([0, 0, B_z]) # B in z-direction r_3, v_3 = simulate_trajectory(v0_3, E_3, B_3)","title":"Scenario 3: Crossed E and B fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization","text":"fig = plt.figure(figsize=(18, 5))","title":"Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-1-2d-plot-xy-plane-circular-motion","text":"ax1 = fig.add_subplot(131) ax1.plot(r_1[:, 0], r_1[:, 1], 'b-', label='Trajectory') ax1.set_xlabel('x (m)') ax1.set_ylabel('y (m)') ax1.set_title('Uniform B Field (Circular Motion)') ax1.grid(True) ax1.legend() ax1.set_aspect('equal')","title":"Scenario 1: 2D Plot (xy-plane, circular motion)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-2-3d-plot-helical-motion-with-e-field","text":"ax2 = fig.add_subplot(132, projection='3d') ax2.plot(r_2[:, 0], r_2[:, 1], r_2[:, 2], 'g-', label='Trajectory') ax2.set_xlabel('x (m)') ax2.set_ylabel('y (m)') ax2.set_zlabel('z (m)') ax2.set_title('Combined E and B Fields (Helical)') ax2.legend()","title":"Scenario 2: 3D Plot (helical motion with E-field)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario-3-2d-plot-xy-plane-drift-motion","text":"ax3 = fig.add_subplot(133) ax3.plot(r_3[:, 0], r_3[:, 1], 'r-', label='Trajectory') ax3.set_xlabel('x (m)') ax3.set_ylabel('y (m)') ax3.set_title('Crossed E and B Fields (Drift)') ax3.grid(True) ax3.legend() ax3.set_aspect('equal') plt.tight_layout() plt.show() Charged particle motion under the Lorentz Force, covering: Circular motion (uniform magnetic field), Helical motion (velocity with component along \ud835\udc35B), E\u00d7B drift (crossed fields). Visuals in colab","title":"Scenario 3: 2D Plot (xy-plane, drift motion)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#results-and-visualizations","text":"The script simulates the following three scenarios:","title":"Results and Visualizations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field","text":"Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (10^6, 0, 0) \\ \\text{m/s} $$ Result : Circular motion in the xy-plane due to Lorentz force. Observation : Larmor radius is visible and consistent with theory.","title":"1. Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-combined-electric-and-magnetic-fields","text":"Electric field: $$ \\mathbf{E} = (10^5, 0, 0) \\ \\text{V/m} $$ Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (10^6, 0, 10^6) \\ \\text{m/s} $$ Result : Helical motion with linear acceleration along the x-axis due to the electric field.","title":"2. Combined Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-crossed-electric-and-magnetic-fields","text":"Electric field: $$ \\mathbf{E} = (0, 10^5, 0) \\ \\text{V/m} $$ Magnetic field: $$ \\mathbf{B} = (0, 0, 0.1) \\ \\text{T} $$ Initial velocity: $$ \\mathbf{v}_0 = (0, 0, 0) \\ \\text{m/s} $$ Result : Uniform drift in the x-direction. Theoretical drift velocity : $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} = \\left(\\frac{E}{B}, 0, 0\\right) = (10^6, 0, 0) \\ \\text{m/s} $$","title":"3. Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-phenomena","text":"Larmor Radius : $$ r_L = \\frac{m v_\\perp}{|q| B} $$ Observed in Scenario 1 as the radius of the circular path in the xy-plane. Drift Velocity : $$ v_d = \\frac{E}{B} $$ Confirmed in Scenario 3 as linear motion in the x-direction. .","title":"Key Phenomena"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"These simulations illustrate the Lorentz force\u2019s role in controlling charged particle motion, bridging theory to applications like accelerators and plasma confinement.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Calculating Equivalent Resistance Using Graph Theory: A Physics Report Fundamentals of Circuits In a circuit: Ohm\u2019s Law : $ V = IR $ (Voltage = Current \u00d7 Resistance). - Series Connection : Resistors are connected end-to-end, and the equivalent resistance is the sum of individual resistances: $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$. - Parallel Connection : Resistors share the same two nodes, and the equivalent resistance is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$, or equivalently, $$ R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ for two resistors. - Nodes and Edges : Junctions (nodes) connect resistors (edges), forming a network that can be simplified step-by-step. Algorithm Description The algorithm for calculating equivalent resistance using graph theory involves: 1. Graph Representation : Model the circuit as a graph with nodes (junctions) and edges (resistors with weights). 2. Series Reduction : Identify and collapse linear chains of resistors into a single edge with resistance equal to their sum. 3. Parallel Reduction : Identify multiple edges between the same pair of nodes and replace them with a single edge whose resistance satisfies the parallel formula. 4. Iteration : Repeat steps 2 and 3 until the graph reduces to a single edge between the start and end nodes, yielding the equivalent resistance. Pseudocode Function CalculateEquivalentResistance(graph, start_node, end_node): While graph has more than one edge: // Series reduction For each node in graph: If node has degree 2 (two neighbors): Neighbors = [n1, n2] R_new = graph[node][n1]['weight'] + graph[node][n2]['weight'] Remove node and its edges Add edge (n1, n2) with weight R_new // Parallel reduction For each pair of nodes (u, v): If multiple edges exist between u and v: R_eq = 1 / (sum(1/R for each edge between u and v)) Replace all edges between u and v with one edge of weight R_eq Return graph[start_node][end_node]['weight'] Example Circuits Simple Series : $$ R_1 = 2\\Omega, R_2 = 3\\Omega $$ \u2192 $$ R_{eq} = 5\\Omega $$. Simple Parallel : $$ R_1 = 4\\Omega, R_2 = 4\\Omega $$ \u2192 $$ R_{eq} = 2\\Omega $$. Nested Configuration : A series of $$ 2\\Omega $$ and a parallel pair of $$ 3\\Omega $$ and $$ 6\\Omega $$. How It Handles Nested Combinations Iteratively simplifies: Series reductions collapse chains, parallel reductions merge multiple paths. Order doesn\u2019t matter for $ R_{eq} $ (circuit laws ensure consistency). Nested cases (e.g., parallel inside series) are handled step-by-step. Examples Example 1: Simple Series Circuit: $ R_1 = 2\u03a9 $ and $ R_2 = 3\u03a9 $ in series. $ R_{eq} = 2 + 3 = 5\u03a9 $. Example 2: Simple Parallel Circuit: $ R_1 = 4\u03a9 $ and $ R_2 = 6\u03a9 $ in parallel. $ R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\u03a9 $. Example 3: Nested Configuration Circuit: $ R_1 = 2\u03a9 $ in series with parallel $ R_2 = 4\u03a9 $, $ R_3 = 6\u03a9 $. Parallel: $ R_{23} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\u03a9 $. Series: $ R_{eq} = 2 + 2.4 = 4.4\u03a9 $. import networkx as nx import matplotlib.pyplot as plt Function to calculate parallel resistance def parallel_resistance(R_list): return 1 / sum(1/R for R in R_list) Function to draw graph def draw_graph(G, title, pos=None): if pos is None: pos = nx.spring_layout(G) plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500, font_size=12) edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show() Example 1: Series G1 = nx.Graph() G1.add_edge('A', 'B', weight=2) # 2\u03a9 G1.add_edge('B', 'C', weight=3) # 3\u03a9 draw_graph(G1, \"Example 1: Series (Before)\") Reduce series R_eq1 = 2 + 3 G1_simplified = nx.Graph() G1_simplified.add_edge('A', 'C', weight=R_eq1) draw_graph(G1_simplified, f\"Example 1: Series (After, R_eq = {R_eq1}\u03a9)\") Example 2: Parallel G2 = nx.Graph() G2.add_edge('A', 'B', weight=4) # 4\u03a9 G2.add_edge('A', 'B', weight=6) # 6\u03a9 (parallel) draw_graph(G2, \"Example 2: Parallel (Before)\") Reduce parallel R_eq2 = parallel_resistance([4, 6]) G2_simplified = nx.Graph() G2_simplified.add_edge('A', 'B', weight=R_eq2) draw_graph(G2_simplified, f\"Example 2: Parallel (After, R_eq = {R_eq2:.1f}\u03a9)\") Example 3: Nested (Series with Parallel) G3 = nx.Graph() G3.add_edge('A', 'B', weight=2) # 2\u03a9 in series G3.add_edge('B', 'C', weight=4) # 4\u03a9 parallel G3.add_edge('B', 'C', weight=6) # 6\u03a9 parallel draw_graph(G3, \"Example 3: Nested (Before)\") Step 1: Reduce parallel R_parallel = parallel_resistance([4, 6]) G3_intermediate = nx.Graph() G3_intermediate.add_edge('A', 'B', weight=2) G3_intermediate.add_edge('B', 'C', weight=R_parallel) draw_graph(G3_intermediate, f\"Example 3: After Parallel (R_parallel = {R_parallel:.1f}\u03a9)\") Step 2: Reduce series R_eq3 = 2 + R_parallel G3_simplified = nx.Graph() G3_simplified.add_edge('A', 'C', weight=R_eq3) draw_graph(G3_simplified, f\"Example 3: Nested (After, R_eq = {R_eq3:.1f}\u03a9)\") Print results print(f\"Example 1 (Series): R_eq = {R_eq1}\u03a9\") print(f\"Example 2 (Parallel): R_eq = {R_eq2:.1f}\u03a9\") print(f\"Example 3 (Nested): R_eq = {R_eq3:.1f}\u03a9\")","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#calculating-equivalent-resistance-using-graph-theory-a-physics-report","text":"","title":"Calculating Equivalent Resistance Using Graph Theory: A Physics Report"},{"location":"1%20Physics/5%20Circuits/Problem_1/#fundamentals-of-circuits","text":"In a circuit: Ohm\u2019s Law : $ V = IR $ (Voltage = Current \u00d7 Resistance). - Series Connection : Resistors are connected end-to-end, and the equivalent resistance is the sum of individual resistances: $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$. - Parallel Connection : Resistors share the same two nodes, and the equivalent resistance is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$, or equivalently, $$ R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ for two resistors. - Nodes and Edges : Junctions (nodes) connect resistors (edges), forming a network that can be simplified step-by-step.","title":"Fundamentals of Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"The algorithm for calculating equivalent resistance using graph theory involves: 1. Graph Representation : Model the circuit as a graph with nodes (junctions) and edges (resistors with weights). 2. Series Reduction : Identify and collapse linear chains of resistors into a single edge with resistance equal to their sum. 3. Parallel Reduction : Identify multiple edges between the same pair of nodes and replace them with a single edge whose resistance satisfies the parallel formula. 4. Iteration : Repeat steps 2 and 3 until the graph reduces to a single edge between the start and end nodes, yielding the equivalent resistance.","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"Function CalculateEquivalentResistance(graph, start_node, end_node): While graph has more than one edge: // Series reduction For each node in graph: If node has degree 2 (two neighbors): Neighbors = [n1, n2] R_new = graph[node][n1]['weight'] + graph[node][n2]['weight'] Remove node and its edges Add edge (n1, n2) with weight R_new // Parallel reduction For each pair of nodes (u, v): If multiple edges exist between u and v: R_eq = 1 / (sum(1/R for each edge between u and v)) Replace all edges between u and v with one edge of weight R_eq Return graph[start_node][end_node]['weight']","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuits","text":"Simple Series : $$ R_1 = 2\\Omega, R_2 = 3\\Omega $$ \u2192 $$ R_{eq} = 5\\Omega $$. Simple Parallel : $$ R_1 = 4\\Omega, R_2 = 4\\Omega $$ \u2192 $$ R_{eq} = 2\\Omega $$. Nested Configuration : A series of $$ 2\\Omega $$ and a parallel pair of $$ 3\\Omega $$ and $$ 6\\Omega $$.","title":"Example Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#how-it-handles-nested-combinations","text":"Iteratively simplifies: Series reductions collapse chains, parallel reductions merge multiple paths. Order doesn\u2019t matter for $ R_{eq} $ (circuit laws ensure consistency). Nested cases (e.g., parallel inside series) are handled step-by-step.","title":"How It Handles Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#examples","text":"","title":"Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series","text":"Circuit: $ R_1 = 2\u03a9 $ and $ R_2 = 3\u03a9 $ in series. $ R_{eq} = 2 + 3 = 5\u03a9 $.","title":"Example 1: Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel","text":"Circuit: $ R_1 = 4\u03a9 $ and $ R_2 = 6\u03a9 $ in parallel. $ R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\u03a9 $.","title":"Example 2: Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration","text":"Circuit: $ R_1 = 2\u03a9 $ in series with parallel $ R_2 = 4\u03a9 $, $ R_3 = 6\u03a9 $. Parallel: $ R_{23} = \\frac{4 \\cdot 6}{4 + 6} = 2.4\u03a9 $. Series: $ R_{eq} = 2 + 2.4 = 4.4\u03a9 $. import networkx as nx import matplotlib.pyplot as plt","title":"Example 3: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#function-to-calculate-parallel-resistance","text":"def parallel_resistance(R_list): return 1 / sum(1/R for R in R_list)","title":"Function to calculate parallel resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#function-to-draw-graph","text":"def draw_graph(G, title, pos=None): if pos is None: pos = nx.spring_layout(G) plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500, font_size=12) edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show()","title":"Function to draw graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series","text":"G1 = nx.Graph() G1.add_edge('A', 'B', weight=2) # 2\u03a9 G1.add_edge('B', 'C', weight=3) # 3\u03a9 draw_graph(G1, \"Example 1: Series (Before)\")","title":"Example 1: Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#reduce-series","text":"R_eq1 = 2 + 3 G1_simplified = nx.Graph() G1_simplified.add_edge('A', 'C', weight=R_eq1) draw_graph(G1_simplified, f\"Example 1: Series (After, R_eq = {R_eq1}\u03a9)\")","title":"Reduce series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel","text":"G2 = nx.Graph() G2.add_edge('A', 'B', weight=4) # 4\u03a9 G2.add_edge('A', 'B', weight=6) # 6\u03a9 (parallel) draw_graph(G2, \"Example 2: Parallel (Before)\")","title":"Example 2: Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#reduce-parallel","text":"R_eq2 = parallel_resistance([4, 6]) G2_simplified = nx.Graph() G2_simplified.add_edge('A', 'B', weight=R_eq2) draw_graph(G2_simplified, f\"Example 2: Parallel (After, R_eq = {R_eq2:.1f}\u03a9)\")","title":"Reduce parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-series-with-parallel","text":"G3 = nx.Graph() G3.add_edge('A', 'B', weight=2) # 2\u03a9 in series G3.add_edge('B', 'C', weight=4) # 4\u03a9 parallel G3.add_edge('B', 'C', weight=6) # 6\u03a9 parallel draw_graph(G3, \"Example 3: Nested (Before)\")","title":"Example 3: Nested (Series with Parallel)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-reduce-parallel","text":"R_parallel = parallel_resistance([4, 6]) G3_intermediate = nx.Graph() G3_intermediate.add_edge('A', 'B', weight=2) G3_intermediate.add_edge('B', 'C', weight=R_parallel) draw_graph(G3_intermediate, f\"Example 3: After Parallel (R_parallel = {R_parallel:.1f}\u03a9)\")","title":"Step 1: Reduce parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-reduce-series","text":"R_eq3 = 2 + R_parallel G3_simplified = nx.Graph() G3_simplified.add_edge('A', 'C', weight=R_eq3) draw_graph(G3_simplified, f\"Example 3: Nested (After, R_eq = {R_eq3:.1f}\u03a9)\")","title":"Step 2: Reduce series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#print-results","text":"print(f\"Example 1 (Series): R_eq = {R_eq1}\u03a9\") print(f\"Example 2 (Parallel): R_eq = {R_eq2:.1f}\u03a9\") print(f\"Example 3 (Nested): R_eq = {R_eq3:.1f}\u03a9\")","title":"Print results"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Central Limit Theorem Simulation Overview This project demonstrates the Central Limit Theorem (CLT) by simulating sampling distributions of the sample mean for three population distributions: uniform, exponential, and binomial. We visualize how these distributions approach normality as the sample size increases. Definitions Central Limit Theorem (CLT) For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the sampling distribution of the sample mean \\(\\bar{X}\\) for samples of size \\(n\\) is approximately normal: \\( \\(\\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\text{ for large } n\\) \\) Sample Mean The average of a sample \\(X_1, X_2, \\ldots, X_n\\) : \\( \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i\\) \\) Population Variance Measures the spread of the population: \\( \\(\\sigma^2 = E\\left[(X - \\mu)^2\\right]\\) \\) Sampling Distribution Variance The variance of the sample mean: \\( \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) \\) Simulation Setup We simulate three population distributions: Uniform Values: Between 0 and 10 Mean: \\(\\mu = 5\\) Variance: \\(\\sigma^2 = \\frac{(10-0)^2}{12} = 8.333\\) Exponential Shape: Skewed, with rate parameter \\(\\lambda = 1\\) Mean: \\(\\mu = \\frac{1}{\\lambda} = 1\\) Variance: \\(\\sigma^2 = \\frac{1}{\\lambda^2} = 1\\) Binomial Shape: Discrete, with trials \\(n=100\\) , probability \\(p=0.2\\) Mean: \\(\\mu = np = 20\\) Variance: \\(\\sigma^2 = np(1-p) = 16\\) Parameters Sample sizes: \\(n = 5, 10, 30, 50\\) Number of samples: 10,000 Output: Each simulation generates histograms of sample means, compiled into a GIF showing the progression across sample sizes. Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns from PIL import Image import os Set random seed for reproducibility np.random.seed(42) Generate population distributions def generate_populations(size=100000): uniform = np.random.uniform(0, 10, size) exponential = np.random.exponential(1, size) binomial = np.random.binomial(100, 0.2, size) return [ (uniform, \"Uniform\", 5, np.sqrt(100/12)), (exponential, \"Exponential\", 1, 1), (binomial, \"Binomial\", 20, np.sqrt(16)) ] Simulate sampling distribution of sample means def simulate_sampling_distribution(population, sample_size, num_samples=10000): sample_means = [np.mean(np.random.choice(population, sample_size)) for _ in range(num_samples)] return np.array(sample_means) Plot histogram with normal approximation def plot_sampling_distribution(means, dist_name, sample_size, mu, sigma, frame_dir, frame_num): plt.figure(figsize=(8, 6)) sns.histplot(means, kde=True, stat=\"density\", color=\"skyblue\") plt.title(f\"{dist_name} Sampling Distribution (n={sample_size})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") # Overlay theoretical normal distribution x = np.linspace(min(means), max(means), 100) plt.plot(x, 1/(sigma/np.sqrt(sample_size) * np.sqrt(2 np.pi)) * np.exp(-(x-mu) 2 / (2 (sigma/np.sqrt(sample_size))**2)), 'r-', label=\"Normal Approximation\") plt.legend() plt.savefig(f\"{frame_dir}/frame_{frame_num}.png\") plt.close() Create GIF for each distribution def create_gif(distributions, sample_sizes=[5, 10, 30, 50], num_samples=10000): for population, dist_name, mu, sigma in distributions: os.makedirs(dist_name, exist_ok=True) frame_num = 0 for n in sample_sizes: means = simulate_sampling_distribution(population, n, num_samples) plot_sampling_distribution(means, dist_name, n, mu, sigma, dist_name, frame_num) frame_num += 1 # Create GIF images = [Image.open(f\"{dist_name}/frame_{i}.png\") for i in range(len(sample_sizes))] images[0].save(f\"{dist_name}.gif\", save_all=True, append_images=images[1:], duration=1000, loop=0) print(f\"Generated {dist_name}.gif\") Results The GIFs illustrate: Uniform: Nearly normal at \\(n=5\\) , with variance \\(\\frac{8.333}{n}\\) . Exponential: Skewed at \\(n=5\\) , approaches normality by \\(n=30\\) , centered at \\(\\mu=1\\) . Binomial: Near-normal even at \\(n=5\\) , centered at \\(\\mu=20\\) , with variance \\(\\frac{16}{n}\\) . Discussion Shape: Skewed distributions (exponential) need larger \\(n\\) for normality than symmetric ones (uniform). Sample Size: Larger \\(n\\) reduces variance, tightening the distribution around \\(\\mu\\) . Variance: Higher population variance (uniform) widens the sampling distribution. Applications: Estimation: CLT supports confidence intervals for means. Quality Control: Monitors product consistency via sample means. Finance: Models aggregated returns as normal. Conclusion The simulations confirm the CLT: sample means converge to a normal distribution as \\(n\\) increases. The GIFs visually demonstrate this for different distributions, highlighting the theorem\u2019s importance in statistics. Visuals in google colab","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"Central Limit Theorem Simulation Overview This project demonstrates the Central Limit Theorem (CLT) by simulating sampling distributions of the sample mean for three population distributions: uniform, exponential, and binomial. We visualize how these distributions approach normality as the sample size increases. Definitions Central Limit Theorem (CLT) For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the sampling distribution of the sample mean \\(\\bar{X}\\) for samples of size \\(n\\) is approximately normal: \\( \\(\\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\text{ for large } n\\) \\) Sample Mean The average of a sample \\(X_1, X_2, \\ldots, X_n\\) : \\( \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i\\) \\) Population Variance Measures the spread of the population: \\( \\(\\sigma^2 = E\\left[(X - \\mu)^2\\right]\\) \\) Sampling Distribution Variance The variance of the sample mean: \\( \\(\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}\\) \\) Simulation Setup We simulate three population distributions: Uniform Values: Between 0 and 10 Mean: \\(\\mu = 5\\) Variance: \\(\\sigma^2 = \\frac{(10-0)^2}{12} = 8.333\\) Exponential Shape: Skewed, with rate parameter \\(\\lambda = 1\\) Mean: \\(\\mu = \\frac{1}{\\lambda} = 1\\) Variance: \\(\\sigma^2 = \\frac{1}{\\lambda^2} = 1\\) Binomial Shape: Discrete, with trials \\(n=100\\) , probability \\(p=0.2\\) Mean: \\(\\mu = np = 20\\) Variance: \\(\\sigma^2 = np(1-p) = 16\\) Parameters Sample sizes: \\(n = 5, 10, 30, 50\\) Number of samples: 10,000 Output: Each simulation generates histograms of sample means, compiled into a GIF showing the progression across sample sizes. Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns from PIL import Image import os Set random seed for reproducibility np.random.seed(42) Generate population distributions def generate_populations(size=100000): uniform = np.random.uniform(0, 10, size) exponential = np.random.exponential(1, size) binomial = np.random.binomial(100, 0.2, size) return [ (uniform, \"Uniform\", 5, np.sqrt(100/12)), (exponential, \"Exponential\", 1, 1), (binomial, \"Binomial\", 20, np.sqrt(16)) ] Simulate sampling distribution of sample means def simulate_sampling_distribution(population, sample_size, num_samples=10000): sample_means = [np.mean(np.random.choice(population, sample_size)) for _ in range(num_samples)] return np.array(sample_means) Plot histogram with normal approximation def plot_sampling_distribution(means, dist_name, sample_size, mu, sigma, frame_dir, frame_num): plt.figure(figsize=(8, 6)) sns.histplot(means, kde=True, stat=\"density\", color=\"skyblue\") plt.title(f\"{dist_name} Sampling Distribution (n={sample_size})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") # Overlay theoretical normal distribution x = np.linspace(min(means), max(means), 100) plt.plot(x, 1/(sigma/np.sqrt(sample_size) * np.sqrt(2 np.pi)) * np.exp(-(x-mu) 2 / (2 (sigma/np.sqrt(sample_size))**2)), 'r-', label=\"Normal Approximation\") plt.legend() plt.savefig(f\"{frame_dir}/frame_{frame_num}.png\") plt.close() Create GIF for each distribution def create_gif(distributions, sample_sizes=[5, 10, 30, 50], num_samples=10000): for population, dist_name, mu, sigma in distributions: os.makedirs(dist_name, exist_ok=True) frame_num = 0 for n in sample_sizes: means = simulate_sampling_distribution(population, n, num_samples) plot_sampling_distribution(means, dist_name, n, mu, sigma, dist_name, frame_num) frame_num += 1 # Create GIF images = [Image.open(f\"{dist_name}/frame_{i}.png\") for i in range(len(sample_sizes))] images[0].save(f\"{dist_name}.gif\", save_all=True, append_images=images[1:], duration=1000, loop=0) print(f\"Generated {dist_name}.gif\") Results The GIFs illustrate: Uniform: Nearly normal at \\(n=5\\) , with variance \\(\\frac{8.333}{n}\\) . Exponential: Skewed at \\(n=5\\) , approaches normality by \\(n=30\\) , centered at \\(\\mu=1\\) . Binomial: Near-normal even at \\(n=5\\) , centered at \\(\\mu=20\\) , with variance \\(\\frac{16}{n}\\) . Discussion Shape: Skewed distributions (exponential) need larger \\(n\\) for normality than symmetric ones (uniform). Sample Size: Larger \\(n\\) reduces variance, tightening the distribution around \\(\\mu\\) . Variance: Higher population variance (uniform) widens the sampling distribution. Applications: Estimation: CLT supports confidence intervals for means. Quality Control: Monitors product consistency via sample means. Finance: Models aggregated returns as normal. Conclusion The simulations confirm the CLT: sample means converge to a normal distribution as \\(n\\) increases. The GIFs visually demonstrate this for different distributions, highlighting the theorem\u2019s importance in statistics. Visuals in google colab","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating Pi using Monte Carlo Methods Motivation Monte Carlo simulations leverage randomness to estimate values, with estimating \u03c0 being a classic example using geometric probability. This approach connects probability, geometry, and computation, offering insights into convergence and efficiency applicable in physics, finance, and computer science. Part 1: Estimating \u03c0 Using a Circle Theoretical Foundation The circle-based Monte Carlo method estimates \u03c0 by generating random points within a square that bounds a unit circle (radius \\(r = 1\\) ). The area of the unit circle is \\(\\pi r^2 = \\pi\\) , and the area of the square is \\(2r \\times 2r = 4\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\( \\(\\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} \\approx \\frac{\\pi}{4}\\) \\) Thus, the estimate for \u03c0 is: \\( \\(\\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}}\\) \\) Simulation We generate random points \\((x, y)\\) uniformly in the square \\([-1, 1] \\times [-1, 1]\\) and count those satisfying \\(x^2 + y^2 \\leq 1\\) (inside the unit circle). Visualization A scatter plot distinguishes points inside (e.g., blue) and outside (e.g., red) the circle. Analysis Accuracy improves with more points, as the estimate converges to \u03c0. The error decreases as \\(O(1/\\sqrt{N})\\) , where \\(N\\) is the number of points, due to the Central Limit Theorem. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Buffon\u2019s Needle problem involves dropping a needle of length \\(l\\) onto a plane with parallel lines spaced \\(d\\) apart ( \\(l \\leq d\\) ). The probability a needle crosses a line depends on its orientation. Consider the needle\u2019s center at \\((x, 0)\\) and its angle \\(\\theta\\) (0 to \\(\\pi\\) ) with the horizontal. The needle crosses a line if its vertical span exceeds the distance to the nearest line. The vertical span is \\(l \\sin\\theta\\) . The needle crosses if \\(l \\sin\\theta > d - (d \\mod x)\\) , but for simplicity with \\(l \\leq d\\) and uniform dropping, the probability is derived as follows: The distance from the center to the nearest line is uniform on \\([0, d/2]\\) . The crossing condition is \\(l \\sin\\theta > \\text{distance to line}\\) . Averaging over \\(\\theta\\) (uniform on \\([0, \\pi]\\) ) and the center position, the probability of crossing is \\(\\frac{2l}{\\pi d}\\) . Thus, the estimate for \u03c0 is: \\( \\(\\pi \\approx \\frac{2l \\cdot N}{\\text{Number of crossings} \\cdot d}\\) \\) where \\(N\\) is the number of throws. Simulation We simulate \\(N\\) needle drops, randomly assigning center \\(x\\) (uniform on \\([0, d]\\) ) and angle \\(\\theta\\) (uniform on \\([0, \\pi]\\) ), counting crossings when \\(l \\sin\\theta > |x \\mod d - d/2|\\) . Tables Method N=100 N=1000 N=10000 Circle 3.12 3.136 3.142 Buffon\u2019s Needle 3.20 3.152 3.145 Visuals Conclusion Both methods estimate \u03c0 effectively, with the circle method offering better consistency and Buffon\u2019s Needle providing a geometric insight. Increasing \\(N\\) improves accuracy, with computational cost scaling linearly.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"Motivation Monte Carlo simulations leverage randomness to estimate values, with estimating \u03c0 being a classic example using geometric probability. This approach connects probability, geometry, and computation, offering insights into convergence and efficiency applicable in physics, finance, and computer science. Part 1: Estimating \u03c0 Using a Circle","title":"Estimating Pi using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"The circle-based Monte Carlo method estimates \u03c0 by generating random points within a square that bounds a unit circle (radius \\(r = 1\\) ). The area of the unit circle is \\(\\pi r^2 = \\pi\\) , and the area of the square is \\(2r \\times 2r = 4\\) . The ratio of points inside the circle to the total points approximates the ratio of their areas: \\( \\(\\frac{\\text{Number of points inside circle}}{\\text{Total number of points}} \\approx \\frac{\\pi}{4}\\) \\) Thus, the estimate for \u03c0 is: \\( \\(\\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{\\text{Total number of points}}\\) \\)","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"We generate random points \\((x, y)\\) uniformly in the square \\([-1, 1] \\times [-1, 1]\\) and count those satisfying \\(x^2 + y^2 \\leq 1\\) (inside the unit circle). Visualization A scatter plot distinguishes points inside (e.g., blue) and outside (e.g., red) the circle. Analysis Accuracy improves with more points, as the estimate converges to \u03c0. The error decreases as \\(O(1/\\sqrt{N})\\) , where \\(N\\) is the number of points, due to the Central Limit","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theorem","text":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle Theoretical Foundation Buffon\u2019s Needle problem involves dropping a needle of length \\(l\\) onto a plane with parallel lines spaced \\(d\\) apart ( \\(l \\leq d\\) ). The probability a needle crosses a line depends on its orientation. Consider the needle\u2019s center at \\((x, 0)\\) and its angle \\(\\theta\\) (0 to \\(\\pi\\) ) with the horizontal. The needle crosses a line if its vertical span exceeds the distance to the nearest line. The vertical span is \\(l \\sin\\theta\\) . The needle crosses if \\(l \\sin\\theta > d - (d \\mod x)\\) , but for simplicity with \\(l \\leq d\\) and uniform dropping, the probability is derived as follows: The distance from the center to the nearest line is uniform on \\([0, d/2]\\) . The crossing condition is \\(l \\sin\\theta > \\text{distance to line}\\) . Averaging over \\(\\theta\\) (uniform on \\([0, \\pi]\\) ) and the center position, the probability of crossing is \\(\\frac{2l}{\\pi d}\\) . Thus, the estimate for \u03c0 is: \\( \\(\\pi \\approx \\frac{2l \\cdot N}{\\text{Number of crossings} \\cdot d}\\) \\) where \\(N\\) is the number of throws. Simulation We simulate \\(N\\) needle drops, randomly assigning center \\(x\\) (uniform on \\([0, d]\\) ) and angle \\(\\theta\\) (uniform on \\([0, \\pi]\\) ), counting crossings when \\(l \\sin\\theta > |x \\mod d - d/2|\\) . Tables Method N=100 N=1000 N=10000 Circle 3.12 3.136 3.142 Buffon\u2019s Needle 3.20 3.152 3.145 Visuals Conclusion Both methods estimate \u03c0 effectively, with the circle method offering better consistency and Buffon\u2019s Needle providing a geometric insight. Increasing \\(N\\) improves accuracy, with computational cost scaling linearly.","title":"Theorem."},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum Motivation: The acceleration g due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring g accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining g is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. Task: Measure the acceleration g due to gravity using a pendulum and in detail analyze the uncertainties in the measurements. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics. Procedure: 1. Materials: A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape. Calculations 1. Mean and Standard Deviation Calculate the mean time $$ \\overline{T_{10}} $$ and standard deviation $$ \\sigma_{T_{10}} $$ \\[ \\overline{T_{10}} = \\frac{1}{n} \\sum_{i=1}^{n} T_{10}^{(i)} \\qquad \\sigma_{T_{10}} = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} \\left( T_{10}^{(i)} - \\overline{T_{10}} \\right)^2} \\] Compute the uncertainty in the mean : \\[ \\Delta T_{10} = \\frac{\\sigma_{T_{10}}}{\\sqrt{n}} \\] 2. Period of One Oscillation \\[ T = \\frac{\\overline{T_{10}}}{10} \\qquad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 3. Gravitational Acceleration \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 4. Propagation of Uncertainty \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Final Results \\[ L = 1.00 \\pm 0.01 \\ \\text{m} \\] \\[ \\overline{T_{10}} = 9.90 \\pm 0.10 \\ \\text{s} \\] \\[ T = 0.990 \\pm 0.010 \\ \\text{s} \\] \\[ g = 9.98 \\pm 0.25 \\ \\text{m/s}^2 \\] Analysis Comparison with the standard value of gravity: \\[ g_{\\text{standard}} = 9.81 \\ \\text{m/s}^2 \\] Sources of Uncertainty : Human reaction time in starting/stopping the timer Measurement error in the length of the pendulum Small-angle approximation Experimental Limitations : Air resistance and friction at the pivot point Limited resolution of stopwatch and ruler Tabulated raw data 10 trials of $$ T_{10} $$ Calculated: Mean $$ T_{10} $$ Standard deviation $$ \\sigma_{T_{10}} $$ Period $$ T $$ Gravitational acceleration $$ g $$ Uncertainty $$ \\Delta g $$ ```import numpy as np import matplotlib.pyplot as plt Example data (replace with your measured values) L = 1.0 # Length in meters Delta_L = 0.01 # Uncertainty in length (m) T_10_measurements = [9.8, 9.9, 10.0, 9.7, 10.1, 9.6, 10.2, 9.8, 10.0, 9.9] # Time for 10 oscillations (s) n = len(T_10_measurements) Calculate mean and standard deviation T_10_mean = np.mean(T_10_measurements) T_10_std = np.std(T_10_measurements) Delta_T_10 = T_10_std / np.sqrt(n) Period and its uncertainty T = T_10_mean / 10 Delta_T = Delta_T_10 / 10 Gravity and its uncertainty g = 4 * np.pi 2 * L / T 2 Delta_g = g * np.sqrt((Delta_L / L) 2 + (2 * Delta_T / T) 2) Tabulated data print(\"Tabulated Data:\") print(f\"L = {L} \u00b1 {Delta_L} m\") print(f\"T_10 measurements = {T_10_measurements} s\") print(f\"Mean T_10 = {T_10_mean:.2f} \u00b1 {Delta_T_10:.2f} s\") print(f\"Period T = {T:.2f} \u00b1 {Delta_T:.2f} s\") print(f\"g = {g:.2f} \u00b1 {Delta_g:.2f} m/s^2\") plt.figure(figsize=(10, 6)) plt.errorbar(range(1, n+1), T_10_measurements, yerr=T_10_std/np.sqrt(n), fmt='o', capsize=5, label='T_10 Measurements') plt.axhline(y=T_10_mean, color='r', linestyle='--', label=f'Mean T_10 = {T_10_mean:.2f} s') plt.xlabel('Trial Number') plt.ylabel('Time for 10 Oscillations (s)') plt.title('Pendulum Oscillation Measurements') plt.legend() plt.grid(True) plt.show() ![alt text](image.png) ```import numpy as np import matplotlib.pyplot as plt # Raw data: times for 10 oscillations (in seconds) t10 = np.array([20.05, 20.12, 20.00, 20.08, 20.15, 20.03, 20.10, 19.98, 20.06, 20.11]) # Number of trials N = len(t10) # 1. Compute mean and standard deviation of t10 mean_t10 = np.mean(t10) std_t10 = np.std(t10, ddof=1) # ddof=1 for sample standard deviation # 2. Compute the period for one oscillation T = mean_t10 / 10.0 # 3. Uncertainties: u_t10_TypeA = std_t10 / np.sqrt(N) # statistical (Type A) u_t10_TypeB = 0.005 / np.sqrt(N) # resolution of stopwatch (Type B) u_t10 = np.sqrt(u_t10_TypeA**2 + u_t10_TypeB**2) # 4. Uncertainty in period T u_T = u_t10 / 10.0 # 5. Given length L and its uncertainty L = 1.000 # meters u_L = 0.0005 # meters (Type B from ruler resolution) # 6. Compute g g = 4 * np.pi**2 * L / T**2 # 7. Partial derivatives for uncertainty propagation dg_dL = 4 * np.pi**2 / T**2 dg_dT = -8 * np.pi**2 * L / T**3 # 8. Combined uncertainty in g u_g = np.sqrt((dg_dL * u_L)**2 + (dg_dT * u_T)**2) # 9. Display results print(\"Mean t10: {:.4f} s\".format(mean_t10)) print(\"Std. dev t10: {:.4f} s\".format(std_t10)) print(\"Period T = t10/10: {:.4f} s\".format(T)) print(\"Uncertainty in T: {:.5f} s\".format(u_T)) print(\"Measured g: {:.5f} \u00b1 {:.5f} m/s^2\".format(g, u_g)) # 10. Create a histogram of single\u2010oscillation periods periods = t10 / 10.0 # array of individual period measurements plt.figure(figsize=(6,4)) plt.hist(periods, bins=5, edgecolor='black', alpha=0.7) plt.title(\"Histogram of Measured Pendulum Periods\") plt.xlabel(\"Period T (s)\") plt.ylabel(\"Frequency\") plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() ```import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import Image, display Ensure Pillow is installed to save GIF animations !pip install Pillow Pendulum parameters L = 1.000 # pendulum length (m) g_val = 9.80665 # standard gravitational acceleration (m/s^2) theta0 = np.deg2rad(10) # initial displacement angle (radians) omega0 = 0.0 # initial angular velocity (rad/s) Derived parameter: angular frequency for small angles omega = np.sqrt(g_val / L) Time array for one period of animation Adjusted t_max to cover slightly more than a full period for smooth looping t_max = 2 * np.pi / omega * 1.1 # seconds (cover slightly more than one full period) fps = 30 # frames per second for the animation total_frames = int(fps * t_max) t = np.linspace(0, t_max, total_frames) Angular displacement as a function of time (small\u2010angle approximation) theta_t = theta0 * np.cos(omega * t) Convert angular displacement to Cartesian coordinates for animation x = L * np.sin(theta_t) y = -L * np.cos(theta_t) Set up the figure and axes fig, ax = plt.subplots(figsize=(5, 5)) Adjust limits to accommodate the full swing including the initial position ax.set_xlim(-L * np.sin(theta0) * 1.2, L * np.sin(theta0) * 1.2) ax.set_ylim(-L * 1.1, 0.2 * L) ax.set_aspect('equal') ax.axis('off') # Hide the axes for a cleaner look Initialize the pendulum rod (line) and bob (marker) line, = ax.plot([], [], lw=2, color='blue') # rod bob, = ax.plot([], [], 'o', markersize=12, color='red') # bob def init(): \"\"\" Initialize the background of each frame. Called once by FuncAnimation. \"\"\" line.set_data([], []) bob.set_data([], []) return line, bob def animate(i): \"\"\" Animation function: updates the rod and bob to frame index i. \"\"\" # Coordinates for the rod: from pivot (0, 0) to bob (x[i], y[i]) rod_x = [0, x[i]] rod_y = [0, y[i]] line.set_data(rod_x, rod_y) # Fix: Pass the bob coordinates as lists to set_data bob.set_data([x[i]], [y[i]]) return line, bob Create the animation object ani = animation.FuncAnimation( fig, # the figure object animate, # animation function frames=total_frames, init_func=init, # initialization function blit=True, interval=1000/fps, # time between frames in ms repeat=True ) Save the animation as a GIF using the \"pillow\" writer gif_filename = 'pendulum_animation.gif' ani.save(gif_filename, writer='pillow', fps=fps) Display the GIF inline in Colab display(Image(filename=gif_filename)) Close the figure to prevent static image from showing below plt.close(fig) ``` 1Visualization","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration g due to gravity is a fundamental constant that influences a wide range of physical phenomena. Measuring g accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining g is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field.","title":"Motivation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the acceleration g due to gravity using a pendulum and in detail analyze the uncertainties in the measurements. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics.","title":"Task:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape.","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-mean-and-standard-deviation","text":"Calculate the mean time $$ \\overline{T_{10}} $$ and standard deviation $$ \\sigma_{T_{10}} $$ \\[ \\overline{T_{10}} = \\frac{1}{n} \\sum_{i=1}^{n} T_{10}^{(i)} \\qquad \\sigma_{T_{10}} = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} \\left( T_{10}^{(i)} - \\overline{T_{10}} \\right)^2} \\] Compute the uncertainty in the mean : \\[ \\Delta T_{10} = \\frac{\\sigma_{T_{10}}}{\\sqrt{n}} \\]","title":"1. Mean and Standard Deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-period-of-one-oscillation","text":"\\[ T = \\frac{\\overline{T_{10}}}{10} \\qquad \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"2. Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-gravitational-acceleration","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"3. Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-propagation-of-uncertainty","text":"\\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\]","title":"4. Propagation of Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results","text":"\\[ L = 1.00 \\pm 0.01 \\ \\text{m} \\] \\[ \\overline{T_{10}} = 9.90 \\pm 0.10 \\ \\text{s} \\] \\[ T = 0.990 \\pm 0.010 \\ \\text{s} \\] \\[ g = 9.98 \\pm 0.25 \\ \\text{m/s}^2 \\]","title":"Final Results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Comparison with the standard value of gravity: \\[ g_{\\text{standard}} = 9.81 \\ \\text{m/s}^2 \\] Sources of Uncertainty : Human reaction time in starting/stopping the timer Measurement error in the length of the pendulum Small-angle approximation Experimental Limitations : Air resistance and friction at the pivot point Limited resolution of stopwatch and ruler Tabulated raw data 10 trials of $$ T_{10} $$ Calculated: Mean $$ T_{10} $$ Standard deviation $$ \\sigma_{T_{10}} $$ Period $$ T $$ Gravitational acceleration $$ g $$ Uncertainty $$ \\Delta g $$ ```import numpy as np import matplotlib.pyplot as plt","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-data-replace-with-your-measured-values","text":"L = 1.0 # Length in meters Delta_L = 0.01 # Uncertainty in length (m) T_10_measurements = [9.8, 9.9, 10.0, 9.7, 10.1, 9.6, 10.2, 9.8, 10.0, 9.9] # Time for 10 oscillations (s) n = len(T_10_measurements)","title":"Example data (replace with your measured values)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-mean-and-standard-deviation","text":"T_10_mean = np.mean(T_10_measurements) T_10_std = np.std(T_10_measurements) Delta_T_10 = T_10_std / np.sqrt(n)","title":"Calculate mean and standard deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#period-and-its-uncertainty","text":"T = T_10_mean / 10 Delta_T = Delta_T_10 / 10","title":"Period and its uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#gravity-and-its-uncertainty","text":"g = 4 * np.pi 2 * L / T 2 Delta_g = g * np.sqrt((Delta_L / L) 2 + (2 * Delta_T / T) 2)","title":"Gravity and its uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tabulated-data","text":"print(\"Tabulated Data:\") print(f\"L = {L} \u00b1 {Delta_L} m\") print(f\"T_10 measurements = {T_10_measurements} s\") print(f\"Mean T_10 = {T_10_mean:.2f} \u00b1 {Delta_T_10:.2f} s\") print(f\"Period T = {T:.2f} \u00b1 {Delta_T:.2f} s\") print(f\"g = {g:.2f} \u00b1 {Delta_g:.2f} m/s^2\") plt.figure(figsize=(10, 6)) plt.errorbar(range(1, n+1), T_10_measurements, yerr=T_10_std/np.sqrt(n), fmt='o', capsize=5, label='T_10 Measurements') plt.axhline(y=T_10_mean, color='r', linestyle='--', label=f'Mean T_10 = {T_10_mean:.2f} s') plt.xlabel('Trial Number') plt.ylabel('Time for 10 Oscillations (s)') plt.title('Pendulum Oscillation Measurements') plt.legend() plt.grid(True) plt.show() ![alt text](image.png) ```import numpy as np import matplotlib.pyplot as plt # Raw data: times for 10 oscillations (in seconds) t10 = np.array([20.05, 20.12, 20.00, 20.08, 20.15, 20.03, 20.10, 19.98, 20.06, 20.11]) # Number of trials N = len(t10) # 1. Compute mean and standard deviation of t10 mean_t10 = np.mean(t10) std_t10 = np.std(t10, ddof=1) # ddof=1 for sample standard deviation # 2. Compute the period for one oscillation T = mean_t10 / 10.0 # 3. Uncertainties: u_t10_TypeA = std_t10 / np.sqrt(N) # statistical (Type A) u_t10_TypeB = 0.005 / np.sqrt(N) # resolution of stopwatch (Type B) u_t10 = np.sqrt(u_t10_TypeA**2 + u_t10_TypeB**2) # 4. Uncertainty in period T u_T = u_t10 / 10.0 # 5. Given length L and its uncertainty L = 1.000 # meters u_L = 0.0005 # meters (Type B from ruler resolution) # 6. Compute g g = 4 * np.pi**2 * L / T**2 # 7. Partial derivatives for uncertainty propagation dg_dL = 4 * np.pi**2 / T**2 dg_dT = -8 * np.pi**2 * L / T**3 # 8. Combined uncertainty in g u_g = np.sqrt((dg_dL * u_L)**2 + (dg_dT * u_T)**2) # 9. Display results print(\"Mean t10: {:.4f} s\".format(mean_t10)) print(\"Std. dev t10: {:.4f} s\".format(std_t10)) print(\"Period T = t10/10: {:.4f} s\".format(T)) print(\"Uncertainty in T: {:.5f} s\".format(u_T)) print(\"Measured g: {:.5f} \u00b1 {:.5f} m/s^2\".format(g, u_g)) # 10. Create a histogram of single\u2010oscillation periods periods = t10 / 10.0 # array of individual period measurements plt.figure(figsize=(6,4)) plt.hist(periods, bins=5, edgecolor='black', alpha=0.7) plt.title(\"Histogram of Measured Pendulum Periods\") plt.xlabel(\"Period T (s)\") plt.ylabel(\"Frequency\") plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() ```import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import Image, display","title":"Tabulated data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#ensure-pillow-is-installed-to-save-gif-animations","text":"!pip install Pillow","title":"Ensure Pillow is installed to save GIF animations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#pendulum-parameters","text":"L = 1.000 # pendulum length (m) g_val = 9.80665 # standard gravitational acceleration (m/s^2) theta0 = np.deg2rad(10) # initial displacement angle (radians) omega0 = 0.0 # initial angular velocity (rad/s)","title":"Pendulum parameters"},{"location":"1%20Physics/7%20Measurements/Problem_1/#derived-parameter-angular-frequency-for-small-angles","text":"omega = np.sqrt(g_val / L)","title":"Derived parameter: angular frequency for small angles"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-array-for-one-period-of-animation","text":"","title":"Time array for one period of animation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#adjusted-t_max-to-cover-slightly-more-than-a-full-period-for-smooth-looping","text":"t_max = 2 * np.pi / omega * 1.1 # seconds (cover slightly more than one full period) fps = 30 # frames per second for the animation total_frames = int(fps * t_max) t = np.linspace(0, t_max, total_frames)","title":"Adjusted t_max to cover slightly more than a full period for smooth looping"},{"location":"1%20Physics/7%20Measurements/Problem_1/#angular-displacement-as-a-function-of-time-smallangle-approximation","text":"theta_t = theta0 * np.cos(omega * t)","title":"Angular displacement as a function of time (small\u2010angle approximation)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#convert-angular-displacement-to-cartesian-coordinates-for-animation","text":"x = L * np.sin(theta_t) y = -L * np.cos(theta_t)","title":"Convert angular displacement to Cartesian coordinates for animation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#set-up-the-figure-and-axes","text":"fig, ax = plt.subplots(figsize=(5, 5))","title":"Set up the figure and axes"},{"location":"1%20Physics/7%20Measurements/Problem_1/#adjust-limits-to-accommodate-the-full-swing-including-the-initial-position","text":"ax.set_xlim(-L * np.sin(theta0) * 1.2, L * np.sin(theta0) * 1.2) ax.set_ylim(-L * 1.1, 0.2 * L) ax.set_aspect('equal') ax.axis('off') # Hide the axes for a cleaner look","title":"Adjust limits to accommodate the full swing including the initial position"},{"location":"1%20Physics/7%20Measurements/Problem_1/#initialize-the-pendulum-rod-line-and-bob-marker","text":"line, = ax.plot([], [], lw=2, color='blue') # rod bob, = ax.plot([], [], 'o', markersize=12, color='red') # bob def init(): \"\"\" Initialize the background of each frame. Called once by FuncAnimation. \"\"\" line.set_data([], []) bob.set_data([], []) return line, bob def animate(i): \"\"\" Animation function: updates the rod and bob to frame index i. \"\"\" # Coordinates for the rod: from pivot (0, 0) to bob (x[i], y[i]) rod_x = [0, x[i]] rod_y = [0, y[i]] line.set_data(rod_x, rod_y) # Fix: Pass the bob coordinates as lists to set_data bob.set_data([x[i]], [y[i]]) return line, bob","title":"Initialize the pendulum rod (line) and bob (marker)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#create-the-animation-object","text":"ani = animation.FuncAnimation( fig, # the figure object animate, # animation function frames=total_frames, init_func=init, # initialization function blit=True, interval=1000/fps, # time between frames in ms repeat=True )","title":"Create the animation object"},{"location":"1%20Physics/7%20Measurements/Problem_1/#save-the-animation-as-a-gif-using-the-pillow-writer","text":"gif_filename = 'pendulum_animation.gif' ani.save(gif_filename, writer='pillow', fps=fps)","title":"Save the animation as a GIF using the \"pillow\" writer"},{"location":"1%20Physics/7%20Measurements/Problem_1/#display-the-gif-inline-in-colab","text":"display(Image(filename=gif_filename))","title":"Display the GIF inline in Colab"},{"location":"1%20Physics/7%20Measurements/Problem_1/#close-the-figure-to-prevent-static-image-from-showing-below","text":"plt.close(fig) ``` 1Visualization","title":"Close the figure to prevent static image from showing below"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus pauline my ssnjbs xbxbsm","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#pauline-my-ssnjbs-xbxbsm","text":"","title":"pauline my ssnjbs xbxbsm"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}