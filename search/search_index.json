{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Projectile motion is governed by Newton\u2019s laws of motion under constant gravitational acceleration. Let\u2019s derive the equations step-by-step. Governing Equations Assume a projectile is launched with initial velocity $ v_0 $ at an angle $ \\theta $ from the horizontal, with no air resistance and constant gravitational acceleration $ g $. The initial conditions are: - Horizontal velocity: $ v_{x0} = v_0 \\cos\\theta $ - Vertical velocity: $ v_{y0} = v_0 \\sin\\theta $ The acceleration is: - $ a_x = 0 $ (no horizontal acceleration) - $ a_y = -g $ (downward gravitational acceleration) The position as a function of time $ t $ is found by integrating the accelerations: - Horizontal: $ x(t) = v_{x0} t = v_0 \\cos\\theta \\, t $ - Vertical: $ y(t) = v_{y0} t - \\frac{1}{2} g t^2 = v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 $ Time of Flight The projectile hits the ground when $ y(t) = 0 $ (assuming launch height is zero): $$ v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 = 0 $$ Factorizing: $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: $t = 0 $ (start) or $ t = \\frac{2 v_0 \\sin\\theta}{g} $ (time of flight). Range The horizontal range $ R $ is the distance traveled when $ t = \\frac{2 v_0 \\sin\\theta}{g} $: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity $ \\sin 2\\theta = 2 \\sin\\theta \\cos\\theta $: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ This is the general form of the range, showing dependence on $ \\theta $, $ v_0 $, and $g $. Family of Solutions The equation $ R = \\frac{v_0^2 \\sin 2\\theta}{g} $ represents a family of solutions parameterized by $ v_0 $ and $ g $. Different initial conditions yield distinct ranges and trajectories. 2. Analysis of the Range The range depends on $ \\sin 2\\theta $, which has a maximum value of 1 when $ 2\\theta = 90^\\circ $, or $ \\theta = 45^\\circ $. Thus, the maximum range is: $$ R_{\\text{max}} = \\frac{v_0^2}{g} \\quad \\text{at} \\quad \\theta = 45^\\circ $$ Initial Velocity ($ v_0 $) : Range scales with $v_0^2 $, so doubling $ v_0 $ quadruples $ R $. Gravitational Acceleration ($ g $) : Range is inversely proportional to $ g \\(. On the Moon (\\) g \\approx 1.62 \\, \\text{m/s}^2 \\(), the range is greater than on Earth (\\) g = 9.81 \\, \\text{m/s}^2 $). Angle ($ \\theta $) : $ R $ is symmetric about $ 45^\\circ $ (e.g., $ \\theta = 30^\\circ $ and $ 60^\\circ $ yield the same range). 3. Practical Applications Sports : A soccer ball\u2019s trajectory depends on kick angle and speed, optimized near $ 45^\\circ $ for distance. Engineering : Artillery and rocket launches adjust $ \\theta $ and $ v_0 $ for target range. Astrophysics : Trajectories on other planets (e.g., Mars, $ g = 3.72 \\, \\text{m/s}^2 $) require adjusted models. Uneven Terrain : Non-zero launch height modifies the time of flight and range (requires quadratic solving). Air Resistance : Introduces damping, reducing range and altering optimal $ \\theta $. 4. Implementation Below is a Python script simulating projectile motion, plotting range vs. angle, and animating a trajectory. Python Code import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants g = 9.81 # m/s^2 (Earth gravity) v0_values = [10, 15, 20] # Initial velocities (m/s) # Range function def range_theta(theta, v0, g): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Trajectory function def trajectory(t, v0, theta, g): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y # Part 1: Range vs Angle Plot theta = np.linspace(0, 90, 91) # Angles from 0 to 90 degrees plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_theta(theta, v0, g) plt.plot(theta, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Part 2: Animation of Trajectory (for v0 = 15 m/s, theta = 45\u00b0) v0_anim = 15 theta_anim = 45 t_flight = 2 * v0_anim * np.sin(np.radians(theta_anim)) / g t = np.linspace(0, t_flight, 100) x, y = trajectory(t, v0_anim, theta_anim, g) fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, max(x) * 1.1) ax.set_ylim(0, max(y) * 1.1) ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Trajectory (v0 = {v0_anim} m/s, \u03b8 = {theta_anim}\u00b0)') ax.grid(True) line, = ax.plot([], [], 'b-', lw=2) point, = ax.plot([], [], 'ro') def init(): line.set_data([], []) point.set_data([], [])RR return line, point def animate(i): line.set_data(x[:i], y[:i]) point.set_data([x[i]], [y[i]]) return line, point anim = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=50, blit=True) plt.close() # Prevents duplicate static plot HTML(anim.to_jshtml()) # Displays animation in Jupyter; save as GIF in VS Code if needed Graphical Outputs Range vs. Angle : The plot shows $ R $vs. \\(\\theta\\) for $ v_0 = 10, 15, 20 \\, \\text{m/s} $, peaking at $ 45^\\circ $. Animation : A trajectory for $ v_0 = 15 \\, \\text{m/s} $ , $ \\theta = 45^\\circ $, showing the parabolic path. Discussion of Limitations Idealized Model : Assumes no air resistance, flat terrain, and constant $ g $. Realistic Factors : Drag : Reduces range; optimal $ \\theta $ shifts below $ 45^\\circ $. Wind : Alters trajectory unpredictably. Height : Non-zero launch height requires solving a quadratic for time of flight. Suggestions : Use numerical methods (e.g., Runge-Kutta) to include drag ($ F_d = -k v^2 $) or wind forces. Conclusion This analysis reveals the elegance of projectile motion\u2019s dependence on $ \\theta $, $ v_0 $, and $ g $, while highlighting its adaptability to real-world scenarios. The computational tools provide visual insights, making it a powerful teaching and engineering tool. Solutions in Colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by Newton\u2019s laws of motion under constant gravitational acceleration. Let\u2019s derive the equations step-by-step.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"Assume a projectile is launched with initial velocity $ v_0 $ at an angle $ \\theta $ from the horizontal, with no air resistance and constant gravitational acceleration $ g $. The initial conditions are: - Horizontal velocity: $ v_{x0} = v_0 \\cos\\theta $ - Vertical velocity: $ v_{y0} = v_0 \\sin\\theta $ The acceleration is: - $ a_x = 0 $ (no horizontal acceleration) - $ a_y = -g $ (downward gravitational acceleration) The position as a function of time $ t $ is found by integrating the accelerations: - Horizontal: $ x(t) = v_{x0} t = v_0 \\cos\\theta \\, t $ - Vertical: $ y(t) = v_{y0} t - \\frac{1}{2} g t^2 = v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 $","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when $ y(t) = 0 $ (assuming launch height is zero): $$ v_0 \\sin\\theta \\, t - \\frac{1}{2} g t^2 = 0 $$ Factorizing: $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: $t = 0 $ (start) or $ t = \\frac{2 v_0 \\sin\\theta}{g} $ (time of flight).","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"The horizontal range $ R $ is the distance traveled when $ t = \\frac{2 v_0 \\sin\\theta}{g} $: $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity $ \\sin 2\\theta = 2 \\sin\\theta \\cos\\theta $: $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ This is the general form of the range, showing dependence on $ \\theta $, $ v_0 $, and $g $.","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The equation $ R = \\frac{v_0^2 \\sin 2\\theta}{g} $ represents a family of solutions parameterized by $ v_0 $ and $ g $. Different initial conditions yield distinct ranges and trajectories.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range depends on $ \\sin 2\\theta $, which has a maximum value of 1 when $ 2\\theta = 90^\\circ $, or $ \\theta = 45^\\circ $. Thus, the maximum range is: $$ R_{\\text{max}} = \\frac{v_0^2}{g} \\quad \\text{at} \\quad \\theta = 45^\\circ $$ Initial Velocity ($ v_0 $) : Range scales with $v_0^2 $, so doubling $ v_0 $ quadruples $ R $. Gravitational Acceleration ($ g $) : Range is inversely proportional to $ g \\(. On the Moon (\\) g \\approx 1.62 \\, \\text{m/s}^2 \\(), the range is greater than on Earth (\\) g = 9.81 \\, \\text{m/s}^2 $). Angle ($ \\theta $) : $ R $ is symmetric about $ 45^\\circ $ (e.g., $ \\theta = 30^\\circ $ and $ 60^\\circ $ yield the same range).","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : A soccer ball\u2019s trajectory depends on kick angle and speed, optimized near $ 45^\\circ $ for distance. Engineering : Artillery and rocket launches adjust $ \\theta $ and $ v_0 $ for target range. Astrophysics : Trajectories on other planets (e.g., Mars, $ g = 3.72 \\, \\text{m/s}^2 $) require adjusted models. Uneven Terrain : Non-zero launch height modifies the time of flight and range (requires quadratic solving). Air Resistance : Introduces damping, reducing range and altering optimal $ \\theta $.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script simulating projectile motion, plotting range vs. angle, and animating a trajectory.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Constants g = 9.81 # m/s^2 (Earth gravity) v0_values = [10, 15, 20] # Initial velocities (m/s) # Range function def range_theta(theta, v0, g): return (v0**2 * np.sin(2 * np.radians(theta))) / g # Trajectory function def trajectory(t, v0, theta, g): x = v0 * np.cos(np.radians(theta)) * t y = v0 * np.sin(np.radians(theta)) * t - 0.5 * g * t**2 return x, y # Part 1: Range vs Angle Plot theta = np.linspace(0, 90, 91) # Angles from 0 to 90 degrees plt.figure(figsize=(10, 6)) for v0 in v0_values: R = range_theta(theta, v0, g) plt.plot(theta, R, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid(True) plt.show() # Part 2: Animation of Trajectory (for v0 = 15 m/s, theta = 45\u00b0) v0_anim = 15 theta_anim = 45 t_flight = 2 * v0_anim * np.sin(np.radians(theta_anim)) / g t = np.linspace(0, t_flight, 100) x, y = trajectory(t, v0_anim, theta_anim, g) fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, max(x) * 1.1) ax.set_ylim(0, max(y) * 1.1) ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title(f'Projectile Trajectory (v0 = {v0_anim} m/s, \u03b8 = {theta_anim}\u00b0)') ax.grid(True) line, = ax.plot([], [], 'b-', lw=2) point, = ax.plot([], [], 'ro') def init(): line.set_data([], []) point.set_data([], [])RR return line, point def animate(i): line.set_data(x[:i], y[:i]) point.set_data([x[i]], [y[i]]) return line, point anim = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=50, blit=True) plt.close() # Prevents duplicate static plot HTML(anim.to_jshtml()) # Displays animation in Jupyter; save as GIF in VS Code if needed","title":"Python Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graphical-outputs","text":"Range vs. Angle : The plot shows $ R $vs. \\(\\theta\\) for $ v_0 = 10, 15, 20 \\, \\text{m/s} $, peaking at $ 45^\\circ $. Animation : A trajectory for $ v_0 = 15 \\, \\text{m/s} $ , $ \\theta = 45^\\circ $, showing the parabolic path.","title":"Graphical Outputs"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion-of-limitations","text":"Idealized Model : Assumes no air resistance, flat terrain, and constant $ g $. Realistic Factors : Drag : Reduces range; optimal $ \\theta $ shifts below $ 45^\\circ $. Wind : Alters trajectory unpredictably. Height : Non-zero launch height requires solving a quadratic for time of flight. Suggestions : Use numerical methods (e.g., Runge-Kutta) to include drag ($ F_d = -k v^2 $) or wind forces.","title":"Discussion of Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis reveals the elegance of projectile motion\u2019s dependence on $ \\theta $, $ v_0 $, and $ g $, while highlighting its adaptability to real-world scenarios. The computational tools provide visual insights, making it a powerful teaching and engineering tool. Solutions in Colab","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l}\\sin(\\theta) = F\\cos(\\omega_d t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration (9.81 m/s\u00b2), - \\(l\\) is the pendulum length, - \\(F\\) is the amplitude of the external driving force, - \\(\\omega_d\\) is the driving frequency, - \\(t\\) is time. Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to a linear damped-driven oscillator: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega_d t) \\] Where \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency. The general solution consists of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) . Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , with coefficients determined by substituting into the equation. The steady-state amplitude exhibits resonance when \\(\\omega_d \\approx \\omega_0\\) , maximized when \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) , amplifying energy input significantly. 2. Analysis of Dynamics Influence of Parameters Damping Coefficient $ b $ : Higher \\(b\\) reduces amplitude and prevents chaos by dissipating energy, stabilizing the system. Driving Amplitude ( \\(F\\) ) : Increasing \\(F\\) can push the system from periodic to chaotic motion, especially at specific frequencies. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance occurs; far from \\(\\omega_0\\) , quasiperiodic or chaotic behavior emerges. Transition to Chaos For large amplitudes or specific \\(\\omega_d\\) , the nonlinear \\(\\sin(\\theta)\\) term dominates, leading to chaotic motion. This is observable via phase portraits and Poincar\u00e9 sections, showing a shift from closed orbits (periodic) to scattered points (chaotic). 3. Practical Applications Energy Harvesting : Piezoelectric devices use forced oscillations to convert mechanical energy to electrical energy. Suspension Bridges : Damping and forcing model wind-induced vibrations, preventing resonance disasters (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits mirror pendulum dynamics, applicable in signal processing. 4. Implementation Computational Model We use the 4th-order Runge-Kutta (RK4) method to solve the nonlinear equation numerically. Below are Python scripts for simulation, visualization, and animation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # gravity (m/s^2) l = 1.0 # length (m) b = 0.5 # damping coefficient F = 1.2 # driving amplitude omega_d = 2.0 # driving frequency omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions theta0 = 0.1 # initial angle (rad) theta_dot0 = 0.0 # initial angular velocity (rad/s) state0 = [theta0, theta_dot0] # Solve ODE solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) # Extract results theta = solution[:, 0] theta_dot = solution[:, 1] # Plotting plt.figure(figsize=(10, 6)) plt.plot(t, theta, label='Angular Displacement') plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel('Theta (rad)') plt.ylabel('Theta_dot (rad/s)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show() Animation Script import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.integrate import odeint # Parameters g = 9.81 l = 1.0 b = 0.5 F = 1.2 omega_d = 2.0 omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) state0 = [0.1, 0.0] solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) theta = solution[:, 0] # Animation setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) line, = ax.plot([], [], 'o-', lw=2) def init(): line.set_data([], []) return line, def animate(i): x = l * np.sin(theta[i]) y = -l * np.cos(theta[i]) line.set_data([0, x], [0, y]) return line, ani = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=20, blit=True) plt.title('Forced Damped Pendulum Animation') plt.grid() ani.save('pendulum_animation.mp4', writer='ffmpeg') plt.show() Solutions in colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the following nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{l}\\sin(\\theta) = F\\cos(\\omega_d t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration (9.81 m/s\u00b2), - \\(l\\) is the pendulum length, - \\(F\\) is the amplitude of the external driving force, - \\(\\omega_d\\) is the driving frequency, - \\(t\\) is time.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), \\(\\sin(\\theta) \\approx \\theta\\) , simplifying the equation to a linear damped-driven oscillator: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2\\theta = F\\cos(\\omega_d t) \\] Where \\(\\omega_0 = \\sqrt{\\frac{g}{l}}\\) is the natural frequency. The general solution consists of a homogeneous solution (transient) and a particular solution (steady-state): Homogeneous solution : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , where \\(\\omega = \\sqrt{\\omega_0^2 - \\left(\\frac{b}{2}\\right)^2}\\) . Particular solution : \\(\\theta_p(t) = C \\cos(\\omega_d t) + D \\sin(\\omega_d t)\\) , with coefficients determined by substituting into the equation. The steady-state amplitude exhibits resonance when \\(\\omega_d \\approx \\omega_0\\) , maximized when \\(\\omega_d = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\) , amplifying energy input significantly.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-parameters","text":"Damping Coefficient $ b $ : Higher \\(b\\) reduces amplitude and prevents chaos by dissipating energy, stabilizing the system. Driving Amplitude ( \\(F\\) ) : Increasing \\(F\\) can push the system from periodic to chaotic motion, especially at specific frequencies. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance occurs; far from \\(\\omega_0\\) , quasiperiodic or chaotic behavior emerges.","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"For large amplitudes or specific \\(\\omega_d\\) , the nonlinear \\(\\sin(\\theta)\\) term dominates, leading to chaotic motion. This is observable via phase portraits and Poincar\u00e9 sections, showing a shift from closed orbits (periodic) to scattered points (chaotic).","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Piezoelectric devices use forced oscillations to convert mechanical energy to electrical energy. Suspension Bridges : Damping and forcing model wind-induced vibrations, preventing resonance disasters (e.g., Tacoma Narrows). Oscillating Circuits : Driven RLC circuits mirror pendulum dynamics, applicable in signal processing.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"We use the 4th-order Runge-Kutta (RK4) method to solve the nonlinear equation numerically. Below are Python scripts for simulation, visualization, and animation. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 # gravity (m/s^2) l = 1.0 # length (m) b = 0.5 # damping coefficient F = 1.2 # driving amplitude omega_d = 2.0 # driving frequency omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions theta0 = 0.1 # initial angle (rad) theta_dot0 = 0.0 # initial angular velocity (rad/s) state0 = [theta0, theta_dot0] # Solve ODE solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) # Extract results theta = solution[:, 0] theta_dot = solution[:, 1] # Plotting plt.figure(figsize=(10, 6)) plt.plot(t, theta, label='Angular Displacement') plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.legend() plt.grid() plt.show() # Phase portrait plt.figure(figsize=(10, 6)) plt.plot(theta, theta_dot, label='Phase Trajectory') plt.xlabel('Theta (rad)') plt.ylabel('Theta_dot (rad/s)') plt.title('Phase Portrait') plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#animation-script","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from scipy.integrate import odeint # Parameters g = 9.81 l = 1.0 b = 0.5 F = 1.2 omega_d = 2.0 omega_0 = np.sqrt(g / l) # Differential equation def pendulum_deriv(state, t, b, omega_0, F, omega_d): theta, theta_dot = state dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - omega_0**2 * np.sin(theta) + F * np.cos(omega_d * t) return [dtheta_dt, dtheta_dot_dt] # Time array t = np.linspace(0, 20, 1000) state0 = [0.1, 0.0] solution = odeint(pendulum_deriv, state0, t, args=(b, omega_0, F, omega_d)) theta = solution[:, 0] # Animation setup fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5, 1.5) ax.set_ylim(-1.5, 1.5) line, = ax.plot([], [], 'o-', lw=2) def init(): line.set_data([], []) return line, def animate(i): x = l * np.sin(theta[i]) y = -l * np.cos(theta[i]) line.set_data([0, x], [0, y]) return line, ani = FuncAnimation(fig, animate, init_func=init, frames=len(t), interval=20, blit=True) plt.title('Forced Damped Pendulum Animation') plt.grid() ani.save('pendulum_animation.mp4', writer='ffmpeg') plt.show() Solutions in colab","title":"Animation Script"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Orbital Radius Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship. Derivation of Kepler's Third Law for Circular Orbits For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) . Implications in Astronomy Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes. Real-World Examples 1. The Moon's Orbit Around Earth Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects). 2. Earth's Orbit Around the Sun Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit. Extension to Elliptical Orbits For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets. Computational Model Python Code for Graphing \\(T^2\\) vs \\(r^3\\) import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun). Python Code for Animation of Circular Orbit import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab Conclusion Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"Kepler's Third Law establishes a fundamental relationship between the square of a celestial body's orbital period ( \\(T^2\\) ) and the cube of its orbital radius ( \\(r^3\\) ). This law, originally derived empirically by Johannes Kepler, was later explained by Isaac Newton through his law of universal gravitation. For circular orbits, it provides a powerful tool to study gravitational interactions, calculate planetary masses, and determine distances in astronomical systems. This report derives the law, explores its implications, analyzes real-world examples, and provides computational models to visualize and verify the relationship.","title":"Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For a body (e.g., a planet or satellite) in a circular orbit around a central mass (e.g., a star or planet), two forces are at play: Centripetal Force : Required to keep the orbiting body in a circular path, given by: $$ F_c = \\frac{m v^2}{r} $$ where \\(m\\) is the mass of the orbiting body, \\(v\\) is its orbital velocity, and \\(r\\) is the orbital radius. Gravitational Force : Provided by the central mass \\(M\\) , given by Newton's law of gravitation: $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant ( \\(G \\approx 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) ). In a stable circular orbit, these forces are equal: $$ \\frac{m v^2}{r} = \\frac{G M m}{r^2} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ v^2 = \\frac{G M}{r} $$ The orbital velocity \\(v\\) is related to the orbital period \\(T\\) by the circumference of the orbit: $$ v = \\frac{2 \\pi r}{T} $$ Square this expression: $$ v^2 = \\frac{4 \\pi^2 r^2}{T^2} $$ Substitute into the force balance equation: $$ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : $$ \\frac{4 \\pi^2 r^2}{G M} = \\frac{T^2}{r} $$ Rearrange: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This is Kepler's Third Law for circular orbits, showing that \\(T^2 \\propto r^3\\) . The constant \\(\\frac{4 \\pi^2}{G M}\\) depends only on the central mass \\(M\\) .","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Calculating Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) can be calculated. For example, the Moon's orbit around Earth allows us to estimate Earth's mass. Determining Distances : For planets orbiting the Sun, comparing \\(T^2/r^3\\) ratios (with \\(M\\) as the Sun's mass) helps calculate orbital radii. Satellite Orbits : Engineers use this law to design orbits for artificial satellites, ensuring they maintain stable periods at specific altitudes.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"Orbital radius: \\(r \\approx 3.844 \\times 10^8 \\, \\text{m}\\) Orbital period: \\(T \\approx 27.32 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{s}\\) Earth's mass: \\(M \\approx 5.972 \\times 10^{24} \\, \\text{kg}\\) Verify: $$ T^2 = (2.36 \\times 10^6)^2 = 5.57 \\times 10^{12} \\, \\text{s}^2 $$ $$ r^3 = (3.844 \\times 10^8)^3 = 5.68 \\times 10^{25} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = \\frac{5.57 \\times 10^{12}}{5.68 \\times 10^{25}} \\approx 9.81 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = \\frac{4 \\pi^2}{6.67430 \\times 10^{-11} \\cdot 5.972 \\times 10^{24}} \\approx 9.90 \\times 10^{-14} \\, \\text{s}^2 \\text{m}^{-3} $$ The values are close, confirming the law holds (slight discrepancies arise due to approximations and elliptical effects).","title":"1. The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-earths-orbit-around-the-sun","text":"Orbital radius: \\(r \\approx 1.496 \\times 10^{11} \\, \\text{m}\\) (1 AU) Orbital period: \\(T \\approx 365.25 \\, \\text{days} = 3.156 \\times 10^7 \\, \\text{s}\\) Sun's mass: \\(M \\approx 1.989 \\times 10^{30} \\, \\text{kg}\\) Verify: $$ T^2 = (3.156 \\times 10^7)^2 = 9.96 \\times 10^{14} \\, \\text{s}^2 $$ $$ r^3 = (1.496 \\times 10^{11})^3 = 3.347 \\times 10^{33} \\, \\text{m}^3 $$ $$ \\frac{T^2}{r^3} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ $$ \\frac{4 \\pi^2}{G M} = 2.97 \\times 10^{-19} \\, \\text{s}^2 \\text{m}^{-3} $$ The match is exact, as expected for a nearly circular orbit.","title":"2. Earth's Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) , and the law becomes: $$ T^2 = \\frac{4 \\pi^2}{G M} a^3 $$ This holds for all bound orbits, making it applicable to comets, asteroids, and exoplanets.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"","title":"Computational Model"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-graphing-t2-vs-r3","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg (Sun's mass) M_earth = 5.972e24 # kg (Earth's mass) # Function to calculate T^2 from r^3 def kepler_third_law(r, M): return (4 * np.pi**2 / (G * M)) * r**3 # Data ranges r_small = np.linspace(1e6, 1e9, 100) # Small orbits (e.g., satellites) r_large = np.linspace(1e10, 5e11, 100) # Planetary orbits # Calculate T^2 for Earth and Sun T2_earth_small = kepler_third_law(r_small, M_earth) T2_sun_large = kepler_third_law(r_large, M_sun) # Plot plt.figure(figsize=(10, 6)) plt.loglog(r_small**3, T2_earth_small, label=\"Earth Satellites\", color=\"blue\") plt.loglog(r_large**3, T2_sun_large, label=\"Solar System Planets\", color=\"orange\") plt.xlabel(\"$r^3$ (m$^3$)\") plt.ylabel(\"$T^2$ (s$^2$)\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$\") plt.legend() plt.grid(True, which=\"both\", ls=\"--\") plt.show() This code plots \\(T^2\\) vs \\(r^3\\) on a log-log scale for two ranges: - Small orbits (e.g., satellites around Earth). - Large orbits (e.g., planets around the Sun).","title":"Python Code for Graphing \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-animation-of-circular-orbit","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Parameters r = 1.496e11 # Orbital radius (1 AU) T = 3.156e7 # Orbital period (1 year in seconds) M = 1.989e30 # Sun's mass # Time array t = np.linspace(0, T, 100) theta = 2 * np.pi * t / T # Angular position # Positions x = r * np.cos(theta) y = r * np.sin(theta) # Set up figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.5*r, 1.5*r) ax.set_ylim(-1.5*r, 1.5*r) ax.set_aspect(\"equal\") ax.grid(True) # Central mass (Sun) ax.plot(0, 0, \"yo\", markersize=20, label=\"Sun\") orbit, = ax.plot([], [], \"b-\", label=\"Orbit\") planet, = ax.plot([], [], \"bo\", markersize=10, label=\"Planet\") ax.legend() # Animation function def update(frame): orbit.set_data(x[:frame], y[:frame]) planet.set_data(x[frame], y[frame]) return orbit, planet # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.title(\"Circular Orbit Simulation\") plt.show() Solutions in colab","title":"Python Code for Animation of Circular Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law is a cornerstone of celestial mechanics, linking orbital periods and radii through gravity. Its applications range from understanding the Moon's orbit to designing satellite trajectories. The computational models confirm the \\(T^2 \\propto r^3\\) relationship across different scales, and the extension to elliptical orbits broadens its utility. These tools and insights deepen our understanding of the universe's gravitational dance.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Definitions First Cosmic Velocity The first cosmic velocity $$ v_1 $$is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body. It is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the celestial body - $ R $ is the radius of the celestial body Second Cosmic Velocity (Escape Velocity) The second cosmic velocity $ v_2 $ is the minimum velocity required for an object to escape a celestial body's gravitational influence without further propulsion. It is given by: $$ v_2 = \\sqrt{2GM/R} $$ Third Cosmic Velocity The third cosmic velocity $ v_3 $ is the velocity required for an object to escape the Sun's gravitational influence from a given planet\u2019s orbit. It is given by: $$ v_3 = \\sqrt{v_2^2 + v_{orb}^2} $$ where $ v_{orb} $ is the orbital velocity of the planet around the Sun. Calculations for Earth, Mars, and Jupiter Using standard values: - Earth: $ M = 5.972 \\times 10^{24} $ kg, $ R = 6371 $ km - Mars: $ M = 6.417 \\times 10^{23} $ kg, $ R = 3389 $ km - Jupiter: $ M = 1.898 \\times 10^{27} $ kg, $ R = 69911 $ km Python Code for Graphs import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6371e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3389e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 69911e3} } # Compute velocities velocities = {} for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) velocities[body] = (v1, v2) # Plot results labels = list(velocities.keys()) v1_values = [vel[0] for vel in velocities.values()] v2_values = [vel[1] for vel in velocities.values()] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8,6)) plt.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") plt.bar(x + width/2, v2_values, width, label=\"Escape Velocity\") plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.legend() plt.title(\"First and Second Cosmic Velocities for Planets\") plt.grid(axis='y', linestyle='--', alpha=0.7) plt.show() Python Code for Animation import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(0, max(v2_values) * 1.2) line, = ax.plot([], [], 'ro', markersize=8) def update(frame): line.set_data(frame, v2_values[frame % len(v2_values)]) return line, ani = animation.FuncAnimation(fig, update, frames=len(v2_values), interval=1000, repeat=True) plt.show() Importance in Space Exploration Satellite Deployment : Understanding $ v_1 $ helps engineers design stable satellite orbits. Interplanetary Missions : Calculating $ v_2 $ ensures spacecraft can leave planetary influence. Interstellar Travel : $ v_3 $ is crucial for designing missions beyond our solar system. Solution in colab","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"Escape Velocities and Cosmic Velocities","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"The first cosmic velocity $$ v_1 $$is the minimum velocity required for an object to maintain a stable circular orbit around a celestial body. It is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the celestial body - $ R $ is the radius of the celestial body","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity $ v_2 $ is the minimum velocity required for an object to escape a celestial body's gravitational influence without further propulsion. It is given by: $$ v_2 = \\sqrt{2GM/R} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"The third cosmic velocity $ v_3 $ is the velocity required for an object to escape the Sun's gravitational influence from a given planet\u2019s orbit. It is given by: $$ v_3 = \\sqrt{v_2^2 + v_{orb}^2} $$ where $ v_{orb} $ is the orbital velocity of the planet around the Sun.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-earth-mars-and-jupiter","text":"Using standard values: - Earth: $ M = 5.972 \\times 10^{24} $ kg, $ R = 6371 $ km - Mars: $ M = 6.417 \\times 10^{23} $ kg, $ R = 3389 $ km - Jupiter: $ M = 1.898 \\times 10^{27} $ kg, $ R = 69911 $ km","title":"Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-graphs","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial bodies data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6371e3}, \"Mars\": {\"M\": 6.417e23, \"R\": 3389e3}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 69911e3} } # Compute velocities velocities = {} for body, data in bodies.items(): M, R = data[\"M\"], data[\"R\"] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) velocities[body] = (v1, v2) # Plot results labels = list(velocities.keys()) v1_values = [vel[0] for vel in velocities.values()] v2_values = [vel[1] for vel in velocities.values()] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8,6)) plt.bar(x - width/2, v1_values, width, label=\"First Cosmic Velocity\") plt.bar(x + width/2, v2_values, width, label=\"Escape Velocity\") plt.xlabel(\"Celestial Bodies\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.legend() plt.title(\"First and Second Cosmic Velocities for Planets\") plt.grid(axis='y', linestyle='--', alpha=0.7) plt.show()","title":"Python Code for Graphs"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-animation","text":"import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(0, 10) ax.set_ylim(0, max(v2_values) * 1.2) line, = ax.plot([], [], 'ro', markersize=8) def update(frame): line.set_data(frame, v2_values[frame % len(v2_values)]) return line, ani = animation.FuncAnimation(fig, update, frames=len(v2_values), interval=1000, repeat=True) plt.show()","title":"Python Code for Animation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"Satellite Deployment : Understanding $ v_1 $ helps engineers design stable satellite orbits. Interplanetary Missions : Calculating $ v_2 $ ensures spacecraft can leave planetary influence. Interstellar Travel : $ v_3 $ is crucial for designing missions beyond our solar system. Solution in colab","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Types of Trajectories The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash. Governing Equations Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show() Python Code for Animation import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(min(x), max(x)) ax.set_ylim(min(y), max(y)) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Animated Payload Trajectory\") trajectory, = ax.plot([], [], 'r-', label='Trajectory') payload, = ax.plot([], [], 'go', markersize=8, label='Payload') def update(frame): trajectory.set_data(x[:frame], y[:frame]) payload.set_data(x[frame], y[frame]) return trajectory, payload ani = animation.FuncAnimation(fig, update, frames=len(x), interval=20, repeat=False) plt.legend() plt.show() Real-World Applications Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Trajectories of a Freely Released Payload Near Earth","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The possible trajectories of a payload are determined by its velocity relative to Earth: 1. Elliptical Orbit (Bound Trajectory): If the payload's velocity is below escape velocity but high enough to avoid reentry, it will enter an elliptical orbit. 2. Parabolic Trajectory (Escape Condition): If the velocity equals the escape velocity, the object follows a parabolic path and eventually leaves Earth's gravity. 3. Hyperbolic Trajectory (Unbound Escape): If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and escapes Earth's gravitational influence. 4. Reentry Trajectory: If the velocity is too low or directed towards Earth, the payload will reenter the atmosphere and crash.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"Newton\u2019s Law of Gravitation governs the motion: $$ F = \\frac{GMm}{r^2} $$ The equation of motion in two dimensions: $$ \\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\hat{r} $$ where: - $ G $ is the gravitational constant $ 6.674 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2} $ - $ M $ is the mass of the Earth $ 5.972 \\times 10^{24} $ kg - $ r $ is the distance of the payload from Earth's center","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.674e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_Earth = 6371e3 # Earth's radius (m) # Function defining the equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Initial conditions (altitude, velocity components) x0, y0 = 0, R_Earth + 500000 # 500 km altitude vx0, vy0 = 7700, 0 # Initial velocity (m/s), varies per scenario # Time span for simulation t_span = (0, 6000) # 6000 seconds simulation t_eval = np.linspace(*t_span, num=1000) # Solve the ODE sol = solve_ivp(equations, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') # Extract results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Payload Trajectory') plt.scatter(0, 0, color='blue', label='Earth', s=200) plt.xlabel('x position (m)') plt.ylabel('y position (m)') plt.title('Payload Trajectory near Earth') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-animation","text":"import matplotlib.animation as animation fig, ax = plt.subplots() ax.set_xlim(min(x), max(x)) ax.set_ylim(min(y), max(y)) ax.set_xlabel(\"x position (m)\") ax.set_ylabel(\"y position (m)\") ax.set_title(\"Animated Payload Trajectory\") trajectory, = ax.plot([], [], 'r-', label='Trajectory') payload, = ax.plot([], [], 'go', markersize=8, label='Payload') def update(frame): trajectory.set_data(x[:frame], y[:frame]) payload.set_data(x[frame], y[frame]) return trajectory, payload ani = animation.FuncAnimation(fig, update, frames=len(x), interval=20, repeat=False) plt.legend() plt.show()","title":"Python Code for Animation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Satellite Deployment: Ensuring a stable orbit for communication and research satellites. Spacecraft Reentry: Understanding reentry trajectories for safe returns. Interplanetary Travel: Planning escape velocities for missions beyond Earth.","title":"Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Fundamentals of Waves Amplitude (A) : The maximum displacement from equilibrium. Wavelength ($$ \\lambda $$) : The distance between successive crests. Wave number ($$ k $$) : $$ k = \\frac{2\\pi}{\\lambda} $$ Frequency (f) : The number of oscillations per unit time. Angular frequency ($$ \\omega $$) : $$ \\omega = 2\\pi f $$ Phase ($$ \\phi $$) : Describes the wave's shift at a point. A single disturbance from a point source is modeled as: \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] where $$ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} $$ is the distance from the $$ i $$-th source to point $$ (x, y) $$. The total displacement at point $$ (x, y) $$ is: \\[ U(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi) \\] Step-by-Step Task Step 1: Choose a Regular Polygon We'll use a regular pentagon for this simulation. Step 2: Position the Sources We place point sources at the vertices of the pentagon. Step 3: Define the Wave Equation Each source emits a wave described above. Step 4: Superposition of Waves We sum all wave contributions at each point. Step 5: Visualize the Interference Pattern Numerical Parameters and Calculations Let's assume the following values: - Amplitude: $$ A = 1.0 $$ - Wavelength: $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{1} = 6.2832 $$ - Frequency: $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ - Initial Phase: $$ \\phi = 0 $$ - Radius of the polygon: 3 units Each wave source is described by: \\[ u_i(x, y, t) = \\cos(6.2832 \\cdot r_i - 6.2832 \\cdot t) \\] where $$ r_i $$ is the distance from each source at the vertex of the pentagon. The resulting wave field is the sum of all five such terms. Python Code import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Define the regular polygon (pentagon) def regular_polygon(n_sides, radius=3): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] sources = regular_polygon(5) # 5 for pentagon # Define the grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) # Superposition function def wave_interference(x, y, sources, t): result = np.zeros_like(x) for (x0, y0) in sources: r = np.sqrt((x - x0)**2 + (y - y0)**2) result += A * np.cos(k * r - omega * t + phi) return result # Static Plot at t = 0 Z = wave_interference(X, Y, sources, 0) plt.figure(figsize=(8, 8)) plt.contourf(X, Y, Z, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Water Surface Interference Pattern - Regular Pentagon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() Observations Constructive Interference : Bright/red regions where waves reinforce. Destructive Interference : Dark/blue regions where waves cancel. Numerical Parameters and Calculations Amplitude : $$ A = 1.0 $$ Wavelength : $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{1.0} = 6.2832 $$ Frequency : $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ Initial Phase : $$ \\phi = 0 $$ Polygon Radius : $$ R = 3 $$ units (distance from center to each vertex) Step-by-Step Example Let\u2019s compute the displacement at point $$ (x, y) = (0, 0) $$ at time $$ t = 0 $$ from one source located at $$ (x_1, y_1) = (3, 0) $$ (one vertex of the pentagon): Distance from source : $$ r_1 = \\sqrt{(x - x_1)^2 + (y - y_1)^2} = \\sqrt{(0 - 3)^2 + (0 - 0)^2} = 3 $$ Wave contribution from that source : $$ u_1 = A \\cos(k r_1 - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 6.2832 \\cdot 0 + 0) = \\cos(18.8496) \\approx -1 $$ all 5 vertices, and sum: $$ U(0, 0, 0) = \\sum_{i=1}^{5} \\cos(6.2832 \\cdot r_i) $$ wave contributions from each of the 5 pentagon vertices to the point at the center of the polygon, i.e., $ (x, y) = (0, 0) $, at time $ t = 0 $. Step-by-Step Calculation at Point (0, 0), Time $t = 0 $ Amplitude $ A = 1.0 $ Wavelength $ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = 6.2832 $ Frequency $ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $ Phase $ \\phi = 0 $ Radius of pentagon: $ R = 3 $ Vertex Coordinates of Pentagon The 5 vertices of a regular pentagon centered at the origin, with radius 3 units: Vertex $ x_i $ $ y_i $ 1 $ 3.0000 $ $ 0.0000 $ 2 $ 0.9270 $ $ 2.8532 $ 3 $ -2.4271 $ $ 1.7634 $ 4 $ -2.4271 $ $ -1.7634 $ 5 $ 0.9270 $ $ -2.8532 $ Distance to (0, 0) from Each Vertex: We compute: $ r_i = \\sqrt{x_i^2 + y_i^2} $ Since all points are exactly 3 units from the center, we have: \\(r_1 = r_2 = r_3 = r_4 = r_5 = 3\\) Wave Contribution from Each Source Using: $ u_i = \\cos(k r_i - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 0 + 0) = \\cos(18.8496)$ $ \\cos(18.8496) \\approx \\cos(6\\pi) = 1.0 $ So each of the five wave contributions is 1.0 at that moment. Final Total Displacement at (0, 0), \\( t = 0 \\) : $ U(0, 0, 0) = \\sum_{i=1}^{5} u_i = 5 \\cdot 1.0 = \\boxed{5.0} $ Summary Table Vertex Coordinates (x, y) Distance 4 r_i $ $u_i = \\cos(k r_i) $ 1 (3.0000, 0.0000) 3.0000 1.0 2 (0.9270, 2.8532) 3.0000 1.0 3 (-2.4271, 1.7634) 3.0000 1.0 4 (-2.4271, -1.7634) 3.0000 1.0 5 (0.9270, -2.8532) 3.0000 1.0 Total Displacement 5.0","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Interference Patterns on a Water Surface","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#fundamentals-of-waves","text":"Amplitude (A) : The maximum displacement from equilibrium. Wavelength ($$ \\lambda $$) : The distance between successive crests. Wave number ($$ k $$) : $$ k = \\frac{2\\pi}{\\lambda} $$ Frequency (f) : The number of oscillations per unit time. Angular frequency ($$ \\omega $$) : $$ \\omega = 2\\pi f $$ Phase ($$ \\phi $$) : Describes the wave's shift at a point. A single disturbance from a point source is modeled as: \\[ u_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] where $$ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} $$ is the distance from the $$ i $$-th source to point $$ (x, y) $$. The total displacement at point $$ (x, y) $$ is: \\[ U(x, y, t) = \\sum_{i=1}^{N} A \\cos(k r_i - \\omega t + \\phi) \\]","title":"Fundamentals of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-task","text":"","title":"Step-by-Step Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-choose-a-regular-polygon","text":"We'll use a regular pentagon for this simulation.","title":"Step 1: Choose a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-position-the-sources","text":"We place point sources at the vertices of the pentagon.","title":"Step 2: Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-define-the-wave-equation","text":"Each source emits a wave described above.","title":"Step 3: Define the Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-superposition-of-waves","text":"We sum all wave contributions at each point.","title":"Step 4: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-visualize-the-interference-pattern","text":"","title":"Step 5: Visualize the Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#numerical-parameters-and-calculations","text":"Let's assume the following values: - Amplitude: $$ A = 1.0 $$ - Wavelength: $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{1} = 6.2832 $$ - Frequency: $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ - Initial Phase: $$ \\phi = 0 $$ - Radius of the polygon: 3 units Each wave source is described by: \\[ u_i(x, y, t) = \\cos(6.2832 \\cdot r_i - 6.2832 \\cdot t) \\] where $$ r_i $$ is the distance from each source at the vertex of the pentagon. The resulting wave field is the sum of all five such terms.","title":"Numerical Parameters and Calculations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Wave parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number f = 1.0 # Frequency omega = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Define the regular polygon (pentagon) def regular_polygon(n_sides, radius=3): return [(radius * np.cos(2 * np.pi * i / n_sides), radius * np.sin(2 * np.pi * i / n_sides)) for i in range(n_sides)] sources = regular_polygon(5) # 5 for pentagon # Define the grid x = np.linspace(-6, 6, 500) y = np.linspace(-6, 6, 500) X, Y = np.meshgrid(x, y) # Superposition function def wave_interference(x, y, sources, t): result = np.zeros_like(x) for (x0, y0) in sources: r = np.sqrt((x - x0)**2 + (y - y0)**2) result += A * np.cos(k * r - omega * t + phi) return result # Static Plot at t = 0 Z = wave_interference(X, Y, sources, 0) plt.figure(figsize=(8, 8)) plt.contourf(X, Y, Z, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.scatter(*zip(*sources), color='black', label='Wave Sources') plt.legend() plt.title('Water Surface Interference Pattern - Regular Pentagon') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Constructive Interference : Bright/red regions where waves reinforce. Destructive Interference : Dark/blue regions where waves cancel.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#numerical-parameters-and-calculations_1","text":"Amplitude : $$ A = 1.0 $$ Wavelength : $$ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = \\frac{2\\pi}{1.0} = 6.2832 $$ Frequency : $$ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $$ Initial Phase : $$ \\phi = 0 $$ Polygon Radius : $$ R = 3 $$ units (distance from center to each vertex)","title":"Numerical Parameters and Calculations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-example","text":"Let\u2019s compute the displacement at point $$ (x, y) = (0, 0) $$ at time $$ t = 0 $$ from one source located at $$ (x_1, y_1) = (3, 0) $$ (one vertex of the pentagon): Distance from source : $$ r_1 = \\sqrt{(x - x_1)^2 + (y - y_1)^2} = \\sqrt{(0 - 3)^2 + (0 - 0)^2} = 3 $$ Wave contribution from that source : $$ u_1 = A \\cos(k r_1 - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 6.2832 \\cdot 0 + 0) = \\cos(18.8496) \\approx -1 $$","title":"Step-by-Step Example"},{"location":"1%20Physics/3%20Waves/Problem_1/#all-5-vertices-and-sum","text":"$$ U(0, 0, 0) = \\sum_{i=1}^{5} \\cos(6.2832 \\cdot r_i) $$ wave contributions from each of the 5 pentagon vertices to the point at the center of the polygon, i.e., $ (x, y) = (0, 0) $, at time $ t = 0 $.","title":"all 5 vertices, and sum:"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-by-step-calculation-at-point-0-0-time-t-0","text":"Amplitude $ A = 1.0 $ Wavelength $ \\lambda = 1.0 \\Rightarrow k = \\frac{2\\pi}{\\lambda} = 6.2832 $ Frequency $ f = 1.0 \\Rightarrow \\omega = 2\\pi f = 6.2832 $ Phase $ \\phi = 0 $ Radius of pentagon: $ R = 3 $","title":"Step-by-Step Calculation at Point (0, 0), Time $t = 0 $"},{"location":"1%20Physics/3%20Waves/Problem_1/#vertex-coordinates-of-pentagon","text":"The 5 vertices of a regular pentagon centered at the origin, with radius 3 units: Vertex $ x_i $ $ y_i $ 1 $ 3.0000 $ $ 0.0000 $ 2 $ 0.9270 $ $ 2.8532 $ 3 $ -2.4271 $ $ 1.7634 $ 4 $ -2.4271 $ $ -1.7634 $ 5 $ 0.9270 $ $ -2.8532 $","title":"Vertex Coordinates of Pentagon"},{"location":"1%20Physics/3%20Waves/Problem_1/#distance-to-0-0-from-each-vertex","text":"We compute: $ r_i = \\sqrt{x_i^2 + y_i^2} $ Since all points are exactly 3 units from the center, we have:","title":"Distance to (0, 0) from Each Vertex:"},{"location":"1%20Physics/3%20Waves/Problem_1/#r_1-r_2-r_3-r_4-r_5-3","text":"","title":"\\(r_1 = r_2 = r_3 = r_4 = r_5 = 3\\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-contribution-from-each-source","text":"Using: $ u_i = \\cos(k r_i - \\omega t + \\phi) = \\cos(6.2832 \\cdot 3 - 0 + 0) = \\cos(18.8496)$ $ \\cos(18.8496) \\approx \\cos(6\\pi) = 1.0 $ So each of the five wave contributions is 1.0 at that moment.","title":"Wave Contribution from Each Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#final-total-displacement-at-0-0-t-0","text":"$ U(0, 0, 0) = \\sum_{i=1}^{5} u_i = 5 \\cdot 1.0 = \\boxed{5.0} $","title":"Final Total Displacement at (0, 0), \\( t = 0 \\):"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary-table","text":"Vertex Coordinates (x, y) Distance 4 r_i $ $u_i = \\cos(k r_i) $ 1 (3.0000, 0.0000) 3.0000 1.0 2 (0.9270, 2.8532) 3.0000 1.0 3 (-2.4271, 1.7634) 3.0000 1.0 4 (-2.4271, -1.7634) 3.0000 1.0 5 (0.9270, -2.8532) 3.0000 1.0 Total Displacement 5.0","title":"Summary Table"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}